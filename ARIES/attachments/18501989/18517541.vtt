WEBVTT

1
00:00:31.030 --> 00:00:32.210
Hello, everyone

2
00:00:34.380 --> 00:00:36.069
George Mulhearn: 8. How's it going?

3
00:00:39.420 --> 00:00:41.410
That's a bad George. How about you?

4
00:00:41.740 --> 00:00:44.920
Bogdan Mircea: And so you you left quite a few comments on, my dear.

5
00:00:46.170 --> 00:00:55.929
Bogdan Mircea: Yeah, yeah, not nothing too bad. There right now. I'm actually really glad that you you were so pedantic, and actually went through a little bit

6
00:00:56.270 --> 00:00:57.629
Bogdan Mircea: from from what I could tell.

7
00:00:57.880 --> 00:01:00.530
Bogdan Mircea: Yeah, I was trying to find

8
00:01:00.870 --> 00:01:06.810
George Mulhearn: more major issues. But I I couldn't really say good job. Oh, well, yeah.

9
00:01:11.530 --> 00:01:12.589
George Mulhearn: hey, Patrick.

10
00:01:12.800 --> 00:01:26.220
Patrik Stas: Hey, George, it's been it's been a while. It's good to have you Have you on the call again. Let's see if a mirror is gonna join. I I I think you would. But i'm not sure. I'll just double thing. I'll just ping him.

11
00:01:26.340 --> 00:01:28.380
Patrik Stas: and then we can start. Perhaps

12
00:01:28.500 --> 00:01:30.070
Patrik Stas: in the meantime.

13
00:01:35.310 --> 00:01:37.530
George Mulhearn: is this is this spot. New.

14
00:01:37.650 --> 00:01:39.800
George Mulhearn: The meeting analytics.

15
00:01:41.520 --> 00:01:46.920
Patrik Stas: Oh, yeah, that's that's something new introduced by Hyper Ledger. Apparently

16
00:01:47.360 --> 00:01:53.330
it's possible to opt out of it. There's some information about what it is in the chat.

17
00:01:53.430 --> 00:02:07.500
Patrik Stas: so I don't know experimentally the last it it started since last meeting, and experimentally I just kept it on. I will see what kind of things this is, what kind of metrics is it going to produce?

18
00:02:08.039 --> 00:02:14.819
Patrik Stas: But I know if we feel uncomfortable because we can turn it off and just have normal

19
00:02:14.860 --> 00:02:19.100
Patrik Stas: meetings without having our voices analyze.

20
00:02:20.610 --> 00:02:29.429
Patrik Stas: It's some sort of a technologies, as I understand, to analyze the like, who you know how the meeting was going. Essentially

21
00:02:29.650 --> 00:02:32.530
Patrik Stas: That makes it.

22
00:02:33.210 --> 00:02:38.010
Miroslav Kovar: Hey, Mira, we have me around the as well.

23
00:02:38.190 --> 00:02:41.380
So let's get started. I'll share my screen

24
00:02:45.360 --> 00:02:56.480
Patrik Stas: so for starter i'll display at this disclaimer. It's per usual hyper ledger policy. The Anti Trust police notice.

25
00:03:15.040 --> 00:03:25.740
Patrik Stas: All right. Let's get into it. So things gonna be interesting. Call today we have, since we have a big changes going on, and both on the Pr.

26
00:03:25.790 --> 00:03:33.100
Patrik Stas: And also some stuff related to serialization. So just a yeah short overview of

27
00:03:33.120 --> 00:03:36.100
Patrik Stas: agenda. Here we this is wrong meeting.

28
00:03:36.380 --> 00:03:37.770
This is

29
00:03:37.820 --> 00:03:39.860
Patrik Stas: this old one. Yeah, this is it?

30
00:03:40.000 --> 00:03:59.110
Patrik Stas: So? Yeah, just as the usual will cover the stuff which we've done, which is going on. We are planning to do and then finish the meeting with the discussion about the serialization approach and sort of philosophy.

31
00:03:59.340 --> 00:04:03.110
Patrik Stas: Yeah, and I I guess that could be interesting discussion here.

32
00:04:03.590 --> 00:04:05.200
So

33
00:04:05.350 --> 00:04:21.480
Patrik Stas: yeah, let's for for starter. We have kind of completely con completed the the Pr. And you, as I understand you did pretty sorry review. So really it's really appreciated.

34
00:04:21.670 --> 00:04:47.030
Patrik Stas: It's a it's a huge Pr: Just for everyone. Anyone else. Perhaps tuning into that call. So we are. We have recently and a previous month or 2 introduced new State machine, like New State Mission for connection protocol, which is, however, not coupled with any sort of mediation.

35
00:04:47.660 --> 00:04:56.280
Patrik Stas: It also the mediation has to be done by the user that consumer of a is V. 6 and themselves.

36
00:04:58.020 --> 00:05:16.730
Patrik Stas: Yeah. And so this is pretty like vanilla connection, doing the minimal amount of things needed to commodate a connection Protocol. And this has been introduced about the month or so ago, and then bog down here

37
00:05:16.740 --> 00:05:26.289
Patrik Stas: to to to initiative, to kind of rewrite it actually, and use a completely new approach as to how we do state machines

38
00:05:26.480 --> 00:05:28.030
Patrik Stas: in there is.

39
00:05:28.170 --> 00:05:36.469
And yeah, it's, it's really great improvement. We have covered, like all details and advantages

40
00:05:36.700 --> 00:05:43.699
Patrik Stas: in a previous call. So feel free to take a look there, if you like, if you are in the details

41
00:05:46.940 --> 00:05:49.120
Patrik Stas: all right.

42
00:05:50.540 --> 00:05:51.450
Patrik Stas: I guess

43
00:05:51.900 --> 00:05:58.340
Patrik Stas: I guess that that that should be enough for a brief introduction of this. Pr: we've done recently.

44
00:05:58.710 --> 00:06:13.250
Patrik Stas: And then yeah, small, small like notice. It's always a a a bright moment when somebody new comes in, and some means. Pr: so we have this small Pr. From roughly

45
00:06:13.370 --> 00:06:21.609
Patrik Stas: it's a fix in Ayles. Some Some method was failing, so this is fixing the issue.

46
00:06:25.350 --> 00:06:26.160
Patrik Stas: No.

47
00:06:26.410 --> 00:06:27.700
Patrik Stas: this is deleted

48
00:06:30.880 --> 00:06:37.920
Patrik Stas: and check the message that left. They opened a new am I? This is this elsewhere? Okay, okay, I see.

49
00:06:39.620 --> 00:06:42.410
Patrik Stas: Is it on different by chance.

50
00:06:43.040 --> 00:06:44.390
Patrik Stas: Maybe there's something.

51
00:06:45.550 --> 00:06:47.460
Patrik Stas: No, it's the same thing, I guess.

52
00:06:47.990 --> 00:06:48.990
Patrik Stas: Yeah.

53
00:06:49.060 --> 00:06:52.589
Patrik Stas: So yeah, Happy to have a a new contributor here.

54
00:06:53.720 --> 00:07:03.960
Patrik Stas: Yeah. And then and the stuff in progress Well, apart from the the State pattern, which is not the marriage, but it's mostly complete.

55
00:07:04.880 --> 00:07:10.969
There's been an interesting Pr. Open from from you.

56
00:07:12.240 --> 00:07:15.010
Patrik Stas: Please.

57
00:07:15.070 --> 00:07:21.810
Patrik Stas: George Charge. Sorry some sort of gave in my mind.

58
00:07:21.900 --> 00:07:28.590
So yeah, I wanted to ask if you can like, Tell us a little bit about it, and how it's going.

59
00:07:29.030 --> 00:07:30.390
George Mulhearn: Yeah.

60
00:07:30.490 --> 00:07:35.260
Patrik Stas: Do you want me to give a quick demo on

61
00:07:35.490 --> 00:07:43.159
George Mulhearn: cool just to just a question on the State patent stuff? What is what is left on that for it to be merged in.

62
00:07:44.150 --> 00:07:57.039
Patrik Stas: I think we we were just like having the final discussions about this serialization format, and that kind of relates to the the end ending of this a meeting, so

63
00:07:57.120 --> 00:08:04.109
Patrik Stas: I think we can leave it for there, but it's pretty much done here. It just like small need picking like, how should this realize?

64
00:08:04.250 --> 00:08:09.959
Patrik Stas: Right? And and yeah, Well, let's let's leave it to the end. So let's do that. You need to find out.

65
00:08:10.920 --> 00:08:15.579
Patrik Stas: or maybe book book done. Do you have anything else in mind other than this?

66
00:08:16.080 --> 00:08:20.240
Bogdan Mircea: No, no, no, that's that's not really it. Once we figure that out. We can.

67
00:08:20.510 --> 00:08:22.260
Bogdan Mircea: Some of my

68
00:08:23.010 --> 00:08:23.860
Patrik Stas: okay.

69
00:08:31.670 --> 00:08:34.330
George Mulhearn: You can see my screen. Okay.

70
00:08:35.179 --> 00:08:36.060
Bogdan Mircea: Yep.

71
00:08:36.590 --> 00:08:37.299
George Mulhearn: Cool.

72
00:08:38.630 --> 00:08:49.850
Patrik Stas: Okay. So so sorry. Just I'll just I'll just. I'll just jump in for for short second, just so short intro about a bubble. This is actually

73
00:08:50.190 --> 00:08:57.389
Patrik Stas: so. So. So this is like a a new approach as to how how to

74
00:08:57.630 --> 00:08:59.330
do as I

75
00:08:59.620 --> 00:09:10.379
Patrik Stas: for a is the 6 right so currently one the existing options for consuming Aries and Ecx. Via as a 5 from different languages

76
00:09:10.560 --> 00:09:16.109
Patrik Stas: for many people, for most people that's like a mobile use cases where they do Java or Ios.

77
00:09:17.700 --> 00:09:31.739
Patrik Stas: and they and they use it. Fight to talk to. That's using the live Vcx portion of the library, which in the long run we would like to deprecate essentially. And instead, we we want to encourage

78
00:09:31.760 --> 00:09:40.029
Patrik Stas: people to to adopt this kind of modern approach of of doing the Fi: so

79
00:09:41.050 --> 00:09:43.610
Patrik Stas: I I guess I guess it's about the invite.

80
00:09:44.350 --> 00:09:46.820
George Mulhearn: Yeah, yeah, exactly.

81
00:09:47.320 --> 00:09:50.810
George Mulhearn: So yeah, yeah, unifies a relatively

82
00:09:51.050 --> 00:09:52.979
George Mulhearn: new tool

83
00:09:53.130 --> 00:10:02.540
George Mulhearn: that lets you create. You know, rappers for cotton, Swift python. And I think javascript soon, hopefully.

84
00:10:04.140 --> 00:10:09.939
George Mulhearn: But it it alleviates like the pain of some of the complexities, and

85
00:10:10.020 --> 00:10:15.560
George Mulhearn: live Vcx. Like having those handle and maps, and using handlers for everything

86
00:10:15.620 --> 00:10:18.490
George Mulhearn: and error, states

87
00:10:18.800 --> 00:10:21.069
George Mulhearn: it. It eliminates a lot of that pain.

88
00:10:24.160 --> 00:10:25.600
George Mulhearn: Yeah. So

89
00:10:25.650 --> 00:10:29.640
George Mulhearn: yeah, I've been just working on a proof of concept just to

90
00:10:30.020 --> 00:10:35.460
George Mulhearn: explain the basics of how it works to you guys, and then

91
00:10:35.780 --> 00:10:39.440
George Mulhearn: I guess we can decide if it's something worth taking further.

92
00:10:41.790 --> 00:10:48.120
George Mulhearn: So I've I've made a a separate create under the Rappers Directory.

93
00:10:48.570 --> 00:10:49.500
George Mulhearn: So

94
00:10:49.750 --> 00:10:54.069
George Mulhearn: how unified works is you create what's called a udl file.

95
00:10:54.150 --> 00:11:00.459
George Mulhearn: and in this Udl file you describe all of the interfaces.

96
00:11:00.620 --> 00:11:07.699
George Mulhearn: interfaces the structs methods that you want to expose, and you know, have wrapped over.

97
00:11:09.270 --> 00:11:10.390
so

98
00:11:10.460 --> 00:11:13.970
George Mulhearn: you can see my Udl file here

99
00:11:14.700 --> 00:11:22.509
George Mulhearn: actually, before I go further into that. So the Udl unify has restrictions on what you can wrap over.

100
00:11:22.630 --> 00:11:28.290
George Mulhearn: So they They're pretty good like. You can wrap over error, types and structs and everything.

101
00:11:28.380 --> 00:11:43.760
George Mulhearn: but they put in certain rules in place such as you can't wrap over Async functions directly. Everything that you wrap over has to be thread, save so they enforce that it's all send in Sync.

102
00:11:46.520 --> 00:11:53.069
George Mulhearn: Yeah. And and so, because of those restrictions, in my opinion, the best approach is usually to

103
00:11:53.160 --> 00:12:01.629
George Mulhearn: create a thin wrapper create, which is what this is here which just thinly wraps over the things that can't be

104
00:12:01.730 --> 00:12:03.819
George Mulhearn: directly interpreted by unify.

105
00:12:05.720 --> 00:12:08.239
George Mulhearn: So that's what you're seeing here.

106
00:12:08.460 --> 00:12:11.079
So, for example, I was

107
00:12:11.100 --> 00:12:14.549
George Mulhearn: working on wrapping over the connection

108
00:12:14.600 --> 00:12:18.790
George Mulhearn: handler the old connection handler, I guess.

109
00:12:20.910 --> 00:12:30.450
George Mulhearn: And yeah, so connection handler, it couldn't be wrapped over directly, because it had a lot of mutations that could go on.

110
00:12:30.510 --> 00:12:31.750
and

111
00:12:32.720 --> 00:12:39.589
George Mulhearn: basically the the approach to solving that is to wrap over it in a in a mutex fashion, so that you can

112
00:12:39.670 --> 00:12:43.150
George Mulhearn: sort of take the lock and then mutate it, and then put it back.

113
00:12:44.340 --> 00:12:45.530
So

114
00:12:45.550 --> 00:12:51.570
George Mulhearn: yeah, here's my thin wrapper over connection. So I've wrapped over some of

115
00:12:51.880 --> 00:12:54.349
George Mulhearn: you know the basic functions that it has.

116
00:12:54.480 --> 00:12:55.680
So

117
00:12:57.210 --> 00:13:01.649
George Mulhearn: this one here is creating a new invider connection.

118
00:13:03.190 --> 00:13:15.499
George Mulhearn: and as I mentioned, you can't wrap over async things directly, so occasionally you'll think you'll see things such as block on, which is just a simple wrapper

119
00:13:15.610 --> 00:13:16.880
to

120
00:13:17.070 --> 00:13:18.860
George Mulhearn: you know, Execute this

121
00:13:20.190 --> 00:13:23.729
George Mulhearn: as a sync function so converting Async to sync.

122
00:13:23.780 --> 00:13:32.970
George Mulhearn: And then, you know, on the Android side or on the Ios side, you'd launch up a a dispatcher. I/O thread or something of that effect.

123
00:13:33.040 --> 00:13:36.100
George Mulhearn: so that it's acting as if it is asing.

124
00:13:38.010 --> 00:13:41.790
George Mulhearn: So yeah it. The general pattern is

125
00:13:41.850 --> 00:13:45.550
George Mulhearn: pretty straightforward. Sorry this create invider.

126
00:13:48.140 --> 00:13:49.350
George Mulhearn: It basically

127
00:13:49.420 --> 00:13:53.460
George Mulhearn: calls on the constructor for connection create invider

128
00:13:54.680 --> 00:14:01.770
Patrik Stas: passing in a handle a passing in a profile which i'll get to next.

129
00:14:01.810 --> 00:14:10.689
Patrik Stas: Yes, yes, of course. So i'm wondering about this. So this is this great invite right? This will be basically this is the function which will then be exposed

130
00:14:10.790 --> 00:14:15.339
Patrik Stas: on the F. A file. This is the Ffi rapper Interface. Right?

131
00:14:15.630 --> 00:14:18.020
George Mulhearn: Yes, Exactly. So this is what

132
00:14:18.260 --> 00:14:28.630
Patrik Stas: and right, right? And so this create. Invite, for example, as you shown the function, it's it's sync, it's it. And and then you are using some sort of blocking.

133
00:14:28.660 --> 00:14:40.820
Patrik Stas: So is it possible that I think you know. Maybe you expand it just now. Maybe I didn't get it. But is it possible to make, create, invite, or a sync? And then I guess you need Fi is

134
00:14:41.410 --> 00:14:50.420
Patrik Stas: having some sort of runtime which which takes, you know, care of executing it. Or do you have to use like always blocking functions?

135
00:14:54.430 --> 00:15:01.920
George Mulhearn: Yeah, I I haven't. I haven't dove too much further into it other than basically blocking the current

136
00:15:02.200 --> 00:15:03.980
George Mulhearn: complete.

137
00:15:05.270 --> 00:15:08.019
George Mulhearn: Yeah, sorry. I can't answer it much further than that.

138
00:15:08.040 --> 00:15:10.399
Patrik Stas: Right?

139
00:15:11.080 --> 00:15:18.209
George Mulhearn: Yeah, this this approach here is actually something I've gotten from Aries Asca. They

140
00:15:18.950 --> 00:15:32.499
George Mulhearn: their python rapper basically calls on to these block functions so that they can call those Async functions, and and they are using this unified approach in Arizona.

141
00:15:32.810 --> 00:15:39.060
George Mulhearn: No, I know they are. No, I've just noticed how they, you know, run Async functions synchronously

142
00:15:39.190 --> 00:15:41.979
George Mulhearn: just by locking the current thread.

143
00:15:42.290 --> 00:15:46.270
Patrik Stas: So they use something like this in the some blocking.

144
00:15:46.620 --> 00:15:49.400
Patrik Stas: Yeah. Yeah. Oh, okay, I see.

145
00:15:54.290 --> 00:16:03.019
Patrik Stas: Yeah, Sorry. I can't answer the question much further than that. Yeah, that's fine. I I was wondering. I think that's gonna be pretty important. I like

146
00:16:03.200 --> 00:16:12.529
Patrik Stas: because because I I I don't think this will be very performant in the current state. For example, if you want to, if you want to like, create

147
00:16:12.540 --> 00:16:26.359
Patrik Stas: 50 invitors, and all of them have to create keys, but each of those calls will be blocking. And, for example, if we call from no jazz, you just have one threat you called 50 times. Then it wouldn't really run in parallel with it.

148
00:16:26.720 --> 00:16:28.840
George Mulhearn: Right? Right?

149
00:16:28.950 --> 00:16:34.880
George Mulhearn: I I guess maybe the thing with that is when you're when you're writing the Android code.

150
00:16:35.040 --> 00:16:40.009
George Mulhearn: That is where you know you can launch up dispatch of threads.

151
00:16:40.180 --> 00:16:42.749
Patrik Stas: Well, right? Hmm.

152
00:16:42.960 --> 00:16:55.879
Patrik Stas: Because for Mobile these would be like sort of like toler tolerable. Maybe that's why they do it on us. Oh, but as Kari as agnostic, it's not necessarily mobile.

153
00:16:56.170 --> 00:17:07.460
Patrik Stas: and I find it surprising that they do this blocking. I find in a bit, Hecky. But yeah, I I don't know that there there the case in Arizascar. But I think it will be

154
00:17:07.579 --> 00:17:19.669
Patrik Stas: apart from how great it looks. You know, this this thing so far, I think the the figure around the using would be like my big, big

155
00:17:20.050 --> 00:17:23.859
Patrik Stas: improvement, or like import and sort of

156
00:17:24.040 --> 00:17:24.810
Patrik Stas: Oh.

157
00:17:25.000 --> 00:17:28.859
Patrik Stas: yeah, enhancements in yeah, in the future.

158
00:17:29.400 --> 00:17:30.990
George Mulhearn: Yeah, yeah, for sure.

159
00:17:33.030 --> 00:17:38.080
George Mulhearn: So so yeah, so that you can see his 2 basic constructors for a connection here

160
00:17:39.390 --> 00:17:45.630
George Mulhearn: where all I'm doing basically is wrapping the original Aries, Vcx connection handler

161
00:17:45.760 --> 00:17:50.459
George Mulhearn: into my own connection, which is unifiable.

162
00:17:51.120 --> 00:18:03.129
George Mulhearn: It's safe for unify. And then you can see here, I've just implemented a couple of the methods which connection has so a simple one and a synchronous one

163
00:18:03.270 --> 00:18:06.030
George Mulhearn: get state. All that has to do is

164
00:18:06.220 --> 00:18:09.640
George Mulhearn: get the handle from the look which I'm storing it in.

165
00:18:09.990 --> 00:18:13.030
George Mulhearn: and then, you know, cool. Get state on it.

166
00:18:14.210 --> 00:18:16.609
George Mulhearn: I'm also doing a translation of state.

167
00:18:16.720 --> 00:18:18.660
just because that email wasn't

168
00:18:19.520 --> 00:18:22.569
George Mulhearn: wasn't unifying immediately.

169
00:18:28.080 --> 00:18:32.820
George Mulhearn: Yeah. So I guess you can. You can sort of see the the basic pattern that's happening here.

170
00:18:34.310 --> 00:18:37.349
George Mulhearn: How you can write these thin rappers over

171
00:18:37.730 --> 00:18:41.480
George Mulhearn: the Aries Vcx objects so structs

172
00:18:42.680 --> 00:18:44.909
to create a unified safe one.

173
00:18:46.590 --> 00:18:47.990
Patrik Stas: And then.

174
00:18:48.210 --> 00:19:02.960
Patrik Stas: yeah, yeah, Sorry I i'll. I'll i'll let you speak. I have the questions, I guess, but i'll i'll I'll I'll I'll just leave you to speak for you. So yeah. So 2 constructors and then all the

175
00:19:03.040 --> 00:19:07.460
George Mulhearn: class methods. And then you can see here we got

176
00:19:07.490 --> 00:19:12.119
George Mulhearn: the 2 constructors which create this connection struct.

177
00:19:12.520 --> 00:19:19.420
George Mulhearn: And then you define in your udl file all of the methods that the connection has. So get state

178
00:19:19.770 --> 00:19:21.360
pay, wise info.

179
00:19:21.420 --> 00:19:22.870
George Mulhearn: and then etc.

180
00:19:23.850 --> 00:19:26.229
George Mulhearn: So yeah, that's what it looks like

181
00:19:26.590 --> 00:19:29.090
George Mulhearn: in the video

182
00:19:29.390 --> 00:19:30.849
George Mulhearn: and how it's represented.

183
00:19:33.380 --> 00:19:35.210
George Mulhearn: Hey? Yeah, I'm: Sorry. What was your question?

184
00:19:35.790 --> 00:19:40.739
Yeah, I was wondering about.

185
00:19:41.190 --> 00:19:47.580
Patrik Stas: Let let's go, for example, to the connection how how we create connections, the the viper code so

186
00:19:48.150 --> 00:20:05.170
Patrik Stas: create, invite, or returns. Some be UN, if a result and breaths are and reps connection. And yeah, and and then from from unifi, you can they? They have some sort of infrastructure which lets you generate the

187
00:20:05.480 --> 00:20:06.310
Patrik Stas: like

188
00:20:06.940 --> 00:20:11.150
Patrik Stas: a code for different languages.

189
00:20:12.190 --> 00:20:13.820
George Mulhearn: Yeah, yeah.

190
00:20:14.280 --> 00:20:15.700
George Mulhearn: yeah. Do you want to see that now?

191
00:20:16.140 --> 00:20:30.459
Patrik Stas: Yeah, maybe we can take a look at it. I what i'm actually interested in where i'm where i'm like aiming towards is I'm. I'm wondering how the memory kind of works like, if you, for example, create connection here.

192
00:20:32.440 --> 00:20:33.840
Patrik Stas: Oh.

193
00:20:33.910 --> 00:20:37.189
Patrik Stas: I like, how is it free? Like? Do you have to.

194
00:20:38.500 --> 00:20:40.569
Patrik Stas: I I guess that's like

195
00:20:40.700 --> 00:20:46.090
Patrik Stas: specific. I I guess there will be different per different languages like

196
00:20:46.450 --> 00:20:54.339
Patrik Stas: It's gonna be. Do you think it's gonna be garbage collector in the language which eventually we all free that connection, I suppose.

197
00:20:54.360 --> 00:20:56.489
Patrik Stas: I suppose that will be the case.

198
00:20:57.040 --> 00:21:07.050
Patrik Stas: That's kind of how it works in the Vcx. Actually. But I wonder how the memory model and the you know allocations and freeing works with the Unifi.

199
00:21:08.380 --> 00:21:09.920
George Mulhearn: Yeah, yeah, it's

200
00:21:10.290 --> 00:21:11.860
George Mulhearn: good question.

201
00:21:12.850 --> 00:21:15.710
George Mulhearn: I'm not sure off the top of my head. So you so you're wondering if.

202
00:21:16.060 --> 00:21:20.959
George Mulhearn: when a connection is garbage collected in an Android application.

203
00:21:21.090 --> 00:21:23.870
George Mulhearn: does it call on to. You know the drop method

204
00:21:23.910 --> 00:21:36.880
Patrik Stas: of the corresponding connection. Yeah, I guess something like that. I I I suppose that it's gonna probably work somewhat like this because you work because in rascal you don't know how long that connection you return here is going to exist, and

205
00:21:36.990 --> 00:21:40.289
Patrik Stas: who's gonna work with it in jail, for example, right?

206
00:21:40.380 --> 00:21:50.439
Patrik Stas: A person can keep it for a long time, so Rascal Doesn't know when to drop it. So I guess it then must become the Java responsibility responsibility to somehow freed

207
00:21:50.670 --> 00:21:52.920
Patrik Stas: this this collection instance.

208
00:21:53.460 --> 00:21:56.299
Bogdan Mircea: I think that makes sense. Essentially.

209
00:21:56.370 --> 00:21:59.630
Bogdan Mircea: Once something. Once the memory crosses the unified boundary.

210
00:22:00.300 --> 00:22:01.909
Bogdan Mircea: I assume that the

211
00:22:03.140 --> 00:22:05.620
Bogdan Mircea: let's say host, language will

212
00:22:05.760 --> 00:22:08.599
Bogdan Mircea: to be responsible for taking care of the memory.

213
00:22:09.250 --> 00:22:15.060
Bogdan Mircea: whereas if you were to create a string in one of these functions, and then it gets dropped at the end of the function.

214
00:22:15.440 --> 00:22:16.680
Bogdan Mircea: That's basically

215
00:22:17.320 --> 00:22:19.670
Bogdan Mircea: the the library's responsibility.

216
00:22:19.880 --> 00:22:21.530
Bogdan Mircea: When it gets compiled.

217
00:22:21.920 --> 00:22:23.000
Bogdan Mircea: the free

218
00:22:23.020 --> 00:22:25.990
Bogdan Mircea: is where the drop is called implicitly.

219
00:22:26.250 --> 00:22:28.440
Bogdan Mircea: were introduced implicitly by the compiler.

220
00:22:29.030 --> 00:22:30.900
Bogdan Mircea: because on the Vcx.

221
00:22:31.480 --> 00:22:32.310
Bogdan Mircea: Oh.

222
00:22:33.880 --> 00:22:35.500
Bogdan Mircea: you're essentially just

223
00:22:37.000 --> 00:22:38.300
Bogdan Mircea: reading a hook

224
00:22:38.380 --> 00:22:43.180
Bogdan Mircea: in the garbage collector to free some parts of the connection map.

225
00:22:43.340 --> 00:22:45.560
Bogdan Mircea: but it wouldn't necessarily have to be like that.

226
00:22:45.640 --> 00:22:47.349
Bogdan Mircea: If you, for instance.

227
00:22:47.660 --> 00:22:51.970
Bogdan Mircea: I mean I don't know exactly how they'll work with javascript and all that. But if we were to

228
00:22:51.990 --> 00:22:55.399
Bogdan Mircea: sort of, I believe that George is doing here in between the connection

229
00:22:55.650 --> 00:22:58.530
Bogdan Mircea: to be removed from the map of the attorney.

230
00:22:58.860 --> 00:22:59.960
Bogdan Mircea: Then

231
00:23:00.830 --> 00:23:03.930
Bogdan Mircea: it it crosses the by boundary, and it's

232
00:23:04.200 --> 00:23:09.349
Bogdan Mircea: implicitly by the right time.

233
00:23:09.540 --> 00:23:10.570
Bogdan Mircea: No, just.

234
00:23:13.370 --> 00:23:20.070
Bogdan Mircea: I just don't know exactly how that mapping would be would be done between the actual structure like the rust type

235
00:23:20.220 --> 00:23:21.490
Bogdan Mircea: and the

236
00:23:21.740 --> 00:23:22.820
Bogdan Mircea: and javascript.

237
00:23:22.990 --> 00:23:23.750
Bogdan Mircea: But yeah.

238
00:23:27.190 --> 00:23:34.439
George Mulhearn: I I think I just worked out a clue on that which I'll I'll get to in a second when I show you the android code.

239
00:23:36.810 --> 00:23:38.160
George Mulhearn: Yeah, yeah. So

240
00:23:38.180 --> 00:23:42.329
basically how it works to generate your bindings is

241
00:23:42.460 --> 00:23:46.609
George Mulhearn: they have this cli tool code unified by and Gen.

242
00:23:46.690 --> 00:23:50.259
George Mulhearn: And you know you specify what language rapid you want.

243
00:23:50.340 --> 00:23:52.440
George Mulhearn: And then you pointed at the audio.

244
00:23:53.770 --> 00:23:54.980
and then

245
00:23:55.260 --> 00:23:57.099
George Mulhearn: that will basically

246
00:23:57.460 --> 00:23:59.400
George Mulhearn: spit out

247
00:23:59.920 --> 00:24:02.610
George Mulhearn: in this case a Colin file

248
00:24:03.810 --> 00:24:10.109
George Mulhearn: which has, you know, those those classes for connection and for the profile holder and all of that stuff

249
00:24:12.130 --> 00:24:14.170
George Mulhearn: along with a bunch of

250
00:24:14.460 --> 00:24:17.059
George Mulhearn: very confusing and bulletp.

251
00:24:21.470 --> 00:24:31.580
George Mulhearn: And and then, of course, you know, similar process to live. Vcx. You have to build this for the appropriate target binary.

252
00:24:31.840 --> 00:24:35.259
George Mulhearn: So in in my case I've just been

253
00:24:35.490 --> 00:24:36.940
building it

254
00:24:38.290 --> 00:24:41.349
George Mulhearn: quite simply, just for the 64 android.

255
00:24:41.460 --> 00:24:46.269
George Mulhearn: This is just stealing scripts from Live Vcx.

256
00:24:47.620 --> 00:24:50.979
George Mulhearn: Then you know that that builds out into you into your binary

257
00:24:54.680 --> 00:24:58.320
George Mulhearn: any questions before I show some android stuff

258
00:25:02.650 --> 00:25:03.959
Bogdan Mircea: not from my side.

259
00:25:05.400 --> 00:25:06.730
Patrik Stas: I'm good as Well.

260
00:25:07.680 --> 00:25:09.110
Patrik Stas: no one can go ahead

261
00:25:12.740 --> 00:25:19.250
George Mulhearn: cool. So yeah, once once you have that generated bindings file and your binary.

262
00:25:21.120 --> 00:25:24.949
George Mulhearn: In this case i'm just dragging into a very simple project

263
00:25:25.090 --> 00:25:35.209
George Mulhearn: to demonstrate how it works, but I imagine you could also pack it up into your AI file, or.

264
00:25:35.900 --> 00:25:39.540
George Mulhearn: however, with Vcx is distributed. I'm not actually too sure

265
00:25:39.620 --> 00:25:41.929
George Mulhearn: about the distribution process.

266
00:25:44.320 --> 00:25:49.870
George Mulhearn: The what what does that distribution process look like in the Vcx for?

267
00:25:50.180 --> 00:25:51.210
George Mulhearn: Android

268
00:25:51.520 --> 00:25:55.190
Patrik Stas: for Android? Well.

269
00:26:00.100 --> 00:26:10.959
Patrik Stas: you know honestly, I I don't remember the details of the it's it's called. You find the pipeline there's a bunch of scripts, you know, building the the library and linking the other libraries

270
00:26:11.190 --> 00:26:13.810
Patrik Stas: together. Then.

271
00:26:14.080 --> 00:26:16.690
Patrik Stas: I guess, in bills.

272
00:26:17.190 --> 00:26:26.129
Patrik Stas: I don't know some, some. What is it? Some what? What are those android archives in? Here? Is it arc a. A. Are

273
00:26:27.250 --> 00:26:30.010
Patrik Stas: something like that, some sort of archive which

274
00:26:30.330 --> 00:26:34.380
Patrik Stas: the the job of rep reason binded to something like that. I guess.

275
00:26:39.500 --> 00:26:43.429
George Mulhearn: Yeah, yeah, cool. Okay? Well, yeah, you could essentially do the same thing where

276
00:26:43.600 --> 00:26:50.759
George Mulhearn: you're packaging up the generated bindings. And then all of your architectures as your J. And I loops.

277
00:26:53.960 --> 00:27:02.869
George Mulhearn: Yeah, cool. So so in this fragment it's just sort of demonstrating what the calls into the binding look like. So

278
00:27:03.250 --> 00:27:07.960
George Mulhearn: take, for example, this button. Here create wallet and profile.

279
00:27:10.110 --> 00:27:19.150
George Mulhearn: What it's doing, is it's calling on to my new Indie profile method which actually forgot to show.

280
00:27:21.250 --> 00:27:24.059
But all that's doing is

281
00:27:24.180 --> 00:27:29.079
George Mulhearn: blocking and creating and opening a wallet and then creating a profile

282
00:27:29.240 --> 00:27:32.139
George Mulhearn: and then wrapping it in a unified, safe manner.

283
00:27:34.280 --> 00:27:39.460
George Mulhearn: So yeah, so that function here maps directly to

284
00:27:39.620 --> 00:27:41.810
George Mulhearn: this one here, and

285
00:27:42.110 --> 00:27:45.080
George Mulhearn: you can see, unifies also

286
00:27:45.220 --> 00:27:48.180
George Mulhearn: turned it into camel case.

287
00:27:48.560 --> 00:27:53.369
George Mulhearn: which it does per language depending on what the language standard is. It's pretty nice.

288
00:27:55.000 --> 00:27:57.290
George Mulhearn: So yeah, so you can see I'm.

289
00:27:57.550 --> 00:28:05.509
George Mulhearn: I've also wrapped over the wallet config struct which I was able to do directly without you know, wrapping it in my own wallet. Config

290
00:28:07.010 --> 00:28:10.260
George Mulhearn: So this is wrapping directly over it, and you can see, unifies

291
00:28:10.410 --> 00:28:18.220
George Mulhearn: generated out this data class with all of the same methods, all the same as the original one.

292
00:28:18.360 --> 00:28:24.550
Patrik Stas: I also have like option, right with the question, Mark, I suppose i'm someone who the Java Syntax.

293
00:28:24.780 --> 00:28:26.820
George Mulhearn: Yeah, yeah, exactly

294
00:28:26.900 --> 00:28:28.459
Patrik Stas: since I

295
00:28:28.690 --> 00:28:29.640
Patrik Stas: I see.

296
00:28:32.450 --> 00:28:45.370
Patrik Stas: And for example, this world, config you you you. You know how many times you kind of define it somewhere. Is it only the in the Udl file, or did you also have to?

297
00:28:45.380 --> 00:28:56.809
Patrik Stas: It? Is it only in you the office, and that links directly to the vault config in a is Vcx, or that you have to like, declare your own kind of what config in the you need 5 wrapper.

298
00:28:57.760 --> 00:29:12.800
George Mulhearn: Yeah. So this one is directly wrapping over the Aires Vcx wallet. Config

299
00:29:13.150 --> 00:29:19.720
Patrik Stas: the the cases like with connection. And you you you need to create your the the thinver right?

300
00:29:19.920 --> 00:29:27.159
George Mulhearn: Yeah, Exactly. So so you can see all of the things that i'm just directly using, and then exposing

301
00:29:27.710 --> 00:29:32.180
George Mulhearn: while it config unifies, able to wrap over that directly.

302
00:29:32.220 --> 00:29:34.920
George Mulhearn: and these ones as well, I believe.

303
00:29:38.770 --> 00:29:43.170
George Mulhearn: So. So yeah, yeah, Well, it config and pass it in. And then I'm.

304
00:29:43.220 --> 00:29:44.100
George Mulhearn: You know.

305
00:29:44.320 --> 00:29:47.129
George Mulhearn: globally storing this profile in this fragment.

306
00:29:49.670 --> 00:29:51.229
And

307
00:29:52.290 --> 00:30:03.699
George Mulhearn: yeah. So so this is what I was talking about before. How it it can be. The applications responsibility to, you know, call these blocking things within its own thread

308
00:30:04.340 --> 00:30:05.929
within an I/O thread.

309
00:30:07.060 --> 00:30:11.660
George Mulhearn: And so that way, how way, I guess you theoretically could you know.

310
00:30:12.160 --> 00:30:14.890
George Mulhearn: fire off? 20 opens at once

311
00:30:14.910 --> 00:30:17.039
George Mulhearn: all different wallets.

312
00:30:23.270 --> 00:30:27.980
George Mulhearn: Yeah. And so this other button here create connection maps to this one.

313
00:30:30.300 --> 00:30:35.699
George Mulhearn: So yeah, this is where i'm calling on that create invider method

314
00:30:35.930 --> 00:30:41.989
George Mulhearn: that I was showing before. And so yeah, that's that constructor for

315
00:30:42.010 --> 00:30:43.340
George Mulhearn: this connection.

316
00:30:45.330 --> 00:30:46.810
which again.

317
00:30:48.990 --> 00:30:51.529
George Mulhearn: is that a. Vcx. Generated one.

318
00:30:52.790 --> 00:30:57.840
George Mulhearn: and then again clearly storing that, and then the lost button.

319
00:30:57.860 --> 00:31:05.309
Patrik Stas: And then, once you have this connection, you create a new connection. Then you can call methods on that object itself, right? I suppose.

320
00:31:05.590 --> 00:31:09.320
George Mulhearn: Yeah, Exactly. So. So this next button here is show state.

321
00:31:09.790 --> 00:31:13.299
George Mulhearn: It's basically showing how you can call methods on it. So

322
00:31:13.340 --> 00:31:17.370
George Mulhearn: connection pair, wise info, returns

323
00:31:17.490 --> 00:31:24.510
George Mulhearn: the pair, wise infer struct which has, you know, Vw: that did, and Pw. Dover Key

324
00:31:25.250 --> 00:31:26.239
George Mulhearn: and that stuff.

325
00:31:27.600 --> 00:31:30.280
George Mulhearn: So see if I can get it to work.

326
00:31:33.550 --> 00:31:39.220
George Mulhearn: So yeah, that button creates and opens the wallet so that you know, initialized

327
00:31:39.740 --> 00:31:47.170
George Mulhearn: that sqlite database, whatever database it was on the device and created the profile. So now

328
00:31:47.340 --> 00:31:52.909
George Mulhearn: this profile is instantiated and ready to be used by this button create connection.

329
00:31:54.290 --> 00:31:55.479
So

330
00:31:55.900 --> 00:32:01.139
George Mulhearn: yeah, as I said, create connection, all it did was use the create, invite a method

331
00:32:02.090 --> 00:32:10.489
George Mulhearn: and then show State, I guess, is probably the most interesting, so you can see by the toast. It's printing out what the State was, which was initial.

332
00:32:10.520 --> 00:32:13.040
George Mulhearn: and then the pairwise info.

333
00:32:13.390 --> 00:32:16.519
George Mulhearn: I see it was able to get all of that data

334
00:32:16.590 --> 00:32:21.399
George Mulhearn: out of the pairwise info, which which means that the the connection

335
00:32:21.500 --> 00:32:23.250
George Mulhearn: when you created, invite a

336
00:32:23.280 --> 00:32:26.870
George Mulhearn: did successfully generate, you know that did. And

337
00:32:27.090 --> 00:32:28.699
within the connection

338
00:32:28.810 --> 00:32:30.949
Patrik Stas: And yeah, I have gone as far to

339
00:32:31.040 --> 00:32:35.530
George Mulhearn: try, mock out an app with, you know, accepting an invite. And

340
00:32:37.670 --> 00:32:46.020
George Mulhearn: yeah, going through the whole connection state, because that'd turn into a pretty significant fragment just for a demo, I guess.

341
00:32:47.520 --> 00:32:50.790
George Mulhearn: Yeah, Any any questions on that?

342
00:32:54.220 --> 00:32:57.789
Bogdan Mircea: I don't know if it's that much of a question. But I do have

343
00:32:58.250 --> 00:33:01.260
Bogdan Mircea: to the wild idea in terms of Async.

344
00:33:01.610 --> 00:33:06.200
Bogdan Mircea: So from from what I can gather, the problem with

345
00:33:07.220 --> 00:33:10.169
Bogdan Mircea: like you unify has this problem with wrapping

346
00:33:10.490 --> 00:33:11.550
Bogdan Mircea: teachers

347
00:33:11.730 --> 00:33:12.420
Bogdan Mircea: right

348
00:33:12.710 --> 00:33:15.650
Bogdan Mircea: and crossing them over the if I boundary.

349
00:33:15.930 --> 00:33:20.619
Bogdan Mircea: because then they have to be executed in some way, just hasting front time, and

350
00:33:20.700 --> 00:33:22.239
Bogdan Mircea: with, and so on, and

351
00:33:22.270 --> 00:33:22.870
Bogdan Mircea: 8

352
00:33:23.240 --> 00:33:24.400
Bogdan Mircea: didn't we

353
00:33:24.580 --> 00:33:29.910
Patrik Stas: Can you try to place your Mike a little bit closer.

354
00:33:30.620 --> 00:33:32.309
Bogdan Mircea: Yeah, I think, My.

355
00:33:33.410 --> 00:33:36.019
Bogdan Mircea: I don't know why my audio always gets messed up

356
00:33:36.050 --> 00:33:37.400
Patrik Stas: every single

357
00:33:37.610 --> 00:33:38.850
Bogdan Mircea: Okay, there we go

358
00:33:40.570 --> 00:33:44.919
Bogdan Mircea: better. Okay, yeah, I was using my laptops microphone for some reason, anyway.

359
00:33:45.030 --> 00:33:47.939
Bogdan Mircea: Yeah. So I was saying that

360
00:33:48.130 --> 00:33:56.840
Bogdan Mircea: the problem is with sending features through the F 5 boundary, because they have to be executed in some languages native as Inc. Event. Look right.

361
00:33:57.200 --> 00:34:03.210
Bogdan Mircea: and what you're doing is you're emulating like you're kind of forcing the Async

362
00:34:03.430 --> 00:34:05.630
functions to

363
00:34:05.950 --> 00:34:09.560
Bogdan Mircea: to be sync by blocking the runtime on each of them.

364
00:34:09.860 --> 00:34:10.949
Bogdan Mircea: What if

365
00:34:11.550 --> 00:34:13.969
Bogdan Mircea: here's a while I the wild idea! What if

366
00:34:14.340 --> 00:34:18.999
Bogdan Mircea: you would actually spawn the the tasks asynchronously.

367
00:34:19.659 --> 00:34:20.959
Bogdan Mircea: and then

368
00:34:21.330 --> 00:34:25.790
Bogdan Mircea: store the join handles and some sort of a hash map or something.

369
00:34:25.920 --> 00:34:29.200
Bogdan Mircea: and in a separate thread. You could pull these

370
00:34:29.270 --> 00:34:30.999
Bogdan Mircea: handles and just

371
00:34:31.030 --> 00:34:33.299
Bogdan Mircea: manually progress the

372
00:34:34.940 --> 00:34:38.039
Bogdan Mircea: the futures like that. And then you could basically just retrieve

373
00:34:38.150 --> 00:34:39.089
Bogdan Mircea: the

374
00:34:39.600 --> 00:34:41.639
the result when

375
00:34:42.080 --> 00:34:53.220
Bogdan Mircea: when the the poll is ready, and send it to some different part of your code. It would be a completely different way of doing things, but this would sort of allow you to do asynchronous stuff

376
00:34:54.030 --> 00:34:59.999
Bogdan Mircea: like you could have just a background thread that only looks in that hash map and just takes everything

377
00:35:00.040 --> 00:35:01.020
Bogdan Mircea: and

378
00:35:01.200 --> 00:35:04.520
Bogdan Mircea: just pulls it constantly. It's doing that all the time.

379
00:35:06.630 --> 00:35:11.849
Bogdan Mircea: And then I know through some identifier. You would know what you put in there, so you know where to send it.

380
00:35:13.390 --> 00:35:14.949
Bogdan Mircea: Does it make any sense?

381
00:35:15.610 --> 00:35:17.469
George Mulhearn: Yeah. Yeah. Yeah, yeah.

382
00:35:18.230 --> 00:35:21.359
George Mulhearn: yeah, yeah, that that that could work

383
00:35:23.200 --> 00:35:39.039
Patrik Stas: sounds like quite like menu manual approach. But I guess maybe I I guess that could be the way. But that's I. I think that's assuming that the unify. If I you you need a 5,000 sort of support

384
00:35:39.050 --> 00:35:51.630
Patrik Stas: I think, natively like. I would imagine that there is easier way to do it, and maybe I I I don't know how how like how deep you do. You need a fire, judge? But

385
00:35:52.570 --> 00:36:02.979
Patrik Stas: perhaps there is a way you can declare as a asing methods and then unify. You need, if I somehow handling it for you like.

386
00:36:03.530 --> 00:36:12.200
Patrik Stas: Yeah. So I don't know how you have it if it works. But, for example, with the the Ni Ni n Api rs the

387
00:36:12.670 --> 00:36:31.670
Patrik Stas: the appro, the Ffi approach to use for no Gs. The the An Api Rs comes with a a runtime, a like a Tokyo, and which is invisible for you. And you just declare this thing methods. And then in javascript, right? So

388
00:36:32.370 --> 00:36:40.980
Patrik Stas: okay, sorry. Yeah. So so I would just expect that something like that should be hopefully possible. You would you need if a fire as well?

389
00:36:44.160 --> 00:36:49.300
Bogdan Mircea: Yeah. But I think that the key difference here is that you need. Ffi is trying to support multiple languages, whereas

390
00:36:49.450 --> 00:36:51.859
Bogdan Mircea: not the Rs is only for node

391
00:36:51.910 --> 00:36:55.740
Bogdan Mircea: like it's targeted, and they it's easier for them to know

392
00:36:55.970 --> 00:37:01.829
Bogdan Mircea: or to to map the internals of rust features to promises in javascript.

393
00:37:02.170 --> 00:37:08.019
Bogdan Mircea: because they they only have one job, whereas you know, if you, if you have unified or you need fi has to be sort of

394
00:37:08.060 --> 00:37:09.789
Bogdan Mircea: transparent about that.

395
00:37:09.840 --> 00:37:16.670
Bogdan Mircea: I don't. I don't say it's not possible I don't know if it's done or not. It's the first time I see this this kind of stuff. So.

396
00:37:16.830 --> 00:37:19.250
Bogdan Mircea: but it's definitely

397
00:37:19.590 --> 00:37:21.149
Bogdan Mircea: more complicated

398
00:37:22.050 --> 00:37:24.029
Bogdan Mircea: then, and not Prs.

399
00:37:26.240 --> 00:37:28.960
Bogdan Mircea: What what do you? What do you know about the

400
00:37:29.390 --> 00:37:35.370
Bogdan Mircea: like, the Async functionalities of unified George like is that supported at all? Or.

401
00:37:38.280 --> 00:37:41.510
George Mulhearn: yeah, I I I don't believe it is.

402
00:37:41.860 --> 00:37:50.160
George Mulhearn: I I don't know, maybe maybe naively. But I I don't really see the problem with doing it this way.

403
00:37:50.330 --> 00:37:57.089
George Mulhearn: Yeah, maybe maybe if you guys could explain more. But this is essentially using Android's

404
00:37:57.110 --> 00:38:00.320
George Mulhearn: thread pull to launch off a thread.

405
00:38:00.400 --> 00:38:01.990
George Mulhearn: and, you know.

406
00:38:02.310 --> 00:38:06.570
George Mulhearn: run this function, which is technically Async, but as being

407
00:38:06.760 --> 00:38:10.569
George Mulhearn: run blocking. But it's blocking this dispatch of thread.

408
00:38:12.360 --> 00:38:17.089
George Mulhearn: So you know, then the threading is in the hands of the Android code, which

409
00:38:17.150 --> 00:38:19.529
George Mulhearn: I think is a a better approach than

410
00:38:19.790 --> 00:38:21.519
George Mulhearn: an Android

411
00:38:21.560 --> 00:38:26.679
George Mulhearn: application, calling into a binary a rust binary that fires off its own threads.

412
00:38:28.240 --> 00:38:29.279
Bogdan Mircea: Well.

413
00:38:30.140 --> 00:38:33.740
Bogdan Mircea: the the thing with that is

414
00:38:34.490 --> 00:38:40.380
Bogdan Mircea: essentially an agent will do a lot of I/O right? So it's going to wait for messages.

415
00:38:40.680 --> 00:38:42.780
We're wait on

416
00:38:43.080 --> 00:38:45.729
Bogdan Mircea: confirmations for sending messages.

417
00:38:45.880 --> 00:38:47.140
Bogdan Mircea: so it

418
00:38:47.210 --> 00:38:48.669
Bogdan Mircea: it's gonna be

419
00:38:48.710 --> 00:38:51.280
Bogdan Mircea: like that's the benefit of the entire Async

420
00:38:51.360 --> 00:38:56.570
Bogdan Mircea: methodology that you have these green threads, which are much more lightweight than

421
00:38:56.740 --> 00:38:59.170
operating system threads.

422
00:38:59.490 --> 00:39:00.850
Bogdan Mircea: And

423
00:39:01.580 --> 00:39:07.449
Bogdan Mircea: even though the the context switching is not as expensive, and you as a user. Are in control of

424
00:39:07.640 --> 00:39:13.850
Bogdan Mircea: that. Whereas when you're using threads, you're sort of at the mercy of the operating system.

425
00:39:16.190 --> 00:39:18.850
Bogdan Mircea: Now what i'm curious about

426
00:39:19.190 --> 00:39:25.269
Bogdan Mircea: again. I don't know any any cotton or Java to this level. So you're dispatching the thread.

427
00:39:25.340 --> 00:39:30.659
Bogdan Mircea: But the Tokyo runtime that you're we're using in rust. Also.

428
00:39:30.950 --> 00:39:32.899
Bogdan Mircea: basically we'll just block

429
00:39:34.040 --> 00:39:35.869
Bogdan Mircea: while executing the

430
00:39:36.760 --> 00:39:39.430
Bogdan Mircea: asynchronous function in a thread.

431
00:39:40.650 --> 00:39:52.329
George Mulhearn: Yeah, yeah, exactly. So I'm: I'm launching a an android thread using, You know, the native Android Thread pool management, and then I block that thread

432
00:39:54.400 --> 00:39:57.140
George Mulhearn: in in rust. I'm blocking that dispatch of thread

433
00:39:57.320 --> 00:39:58.620
here

434
00:39:58.680 --> 00:40:00.509
George Mulhearn: so, and if I will

435
00:40:00.670 --> 00:40:07.060
George Mulhearn: through this. Then it's gonna launch 4 different threads, and each one of them are gonna get blocked separately.

436
00:40:08.580 --> 00:40:10.340
Bogdan Mircea: Well, that's the thing.

437
00:40:10.360 --> 00:40:19.400
Bogdan Mircea: Did you? Did you actually test that because the runtime like when you're blocking the runtime in Tokyo, you are blocking the entire runtime

438
00:40:21.430 --> 00:40:28.399
Bogdan Mircea: right? Right? Right? Right? I I I could be wrong. But I I believe that's basically the whole point

439
00:40:30.000 --> 00:40:34.650
Bogdan Mircea: like that's that's the whole point of of blocking it on what you could do instead.

440
00:40:34.670 --> 00:40:36.620
Bogdan Mircea: But again, that sort of implies

441
00:40:39.400 --> 00:40:42.270
Bogdan Mircea: there was some, some you can basically

442
00:40:42.670 --> 00:40:44.350
Bogdan Mircea: issue a.

443
00:40:47.710 --> 00:40:51.620
Bogdan Mircea: Yeah, I don't know, even if you, if you spawn

444
00:40:51.820 --> 00:40:58.919
Bogdan Mircea: a blocking task that's still sort of executing in a different thread, and you have You get a joint handle and you have to retrieve the value.

445
00:41:00.420 --> 00:41:09.059
Bogdan Mircea: But yeah, right now, I I believe that what's actually happened is that you You spawn all these 4 threads and you dispatch them in the Android app. But

446
00:41:09.390 --> 00:41:14.010
Bogdan Mircea: the underlying runtime is gets blocked on each of them.

447
00:41:14.040 --> 00:41:16.479
Bogdan Mircea: and that they do not run independently.

448
00:41:17.070 --> 00:41:19.289
George Mulhearn: Right? Yeah, I I see what you mean.

449
00:41:23.660 --> 00:41:24.229
Hmm.

450
00:41:24.580 --> 00:41:27.240
Bogdan Mircea: I mean, I guess what you would have to do

451
00:41:28.100 --> 00:41:38.439
Bogdan Mircea: to like you, could you? I'm not even sure if you need the runtime to that extent. You could just create a future and do a while, and just call the poll method on it until you get ready

452
00:41:39.060 --> 00:41:40.270
Bogdan Mircea: right.

453
00:41:41.050 --> 00:41:43.290
Bogdan Mircea: And that would essentially

454
00:41:43.880 --> 00:41:48.529
Bogdan Mircea: like creating a mini runtime for each of each of the of the futures

455
00:41:51.040 --> 00:41:57.979
Bogdan Mircea: I don't know. But honestly, I think like, if you want the most efficient way to go about, it would be sort of that.

456
00:41:58.100 --> 00:42:04.229
like letting the Tokyo runtime do its thing spawning tasks, and then just going through the tasks

457
00:42:04.540 --> 00:42:08.959
Bogdan Mircea: and retrieving the values as they're done in the background threads

458
00:42:10.620 --> 00:42:11.769
George Mulhearn: right? Yeah.

459
00:42:15.320 --> 00:42:18.549
Bogdan Mircea: I don't know again. I I could be wrong. I don't. I don't know for sure.

460
00:42:18.620 --> 00:42:23.219
Bogdan Mircea: But I you can go around with it and test this block on thing.

461
00:42:26.850 --> 00:42:32.050
Bogdan Mircea: Do you create a new runtime, or is it just created once? I believe it was lazily created once?

462
00:42:32.810 --> 00:42:35.360
George Mulhearn: Yeah, it was, yeah, you're right. So it would.

463
00:42:35.520 --> 00:42:40.349
Bogdan Mircea: Yeah. Yeah. Yeah. Yeah, Good Point: Good Point.

464
00:42:42.340 --> 00:42:46.120
Bogdan Mircea: Yeah. Now, the thing with I don't think you can create multiple runtimes, either.

465
00:42:46.290 --> 00:42:47.450
Bogdan Mircea: Not yeah.

466
00:42:47.940 --> 00:42:48.689
Bogdan Mircea: yeah.

467
00:42:49.020 --> 00:42:50.959
Bogdan Mircea: Maybe actually.

468
00:42:51.880 --> 00:43:00.970
Bogdan Mircea: I don't know about current thread run times. So you can create a runtime in Tokyo like with just a single thread a single threaded on time. And maybe if you create

469
00:43:01.220 --> 00:43:03.840
Bogdan Mircea: that kind of a runtime every time you

470
00:43:04.360 --> 00:43:06.569
Bogdan Mircea: you call this block on function.

471
00:43:06.930 --> 00:43:08.970
Bogdan Mircea: maybe that would

472
00:43:09.440 --> 00:43:10.250
Bogdan Mircea: work

473
00:43:11.000 --> 00:43:14.000
Bogdan Mircea: like it would be fairly easier to implement.

474
00:43:14.340 --> 00:43:15.479
Bogdan Mircea: But

475
00:43:16.280 --> 00:43:18.420
Bogdan Mircea: yeah, and then you could actually get like

476
00:43:18.820 --> 00:43:23.319
Bogdan Mircea: one thread one run time, and you can dispatch them, and they would actually run a parallel like this.

477
00:43:25.160 --> 00:43:26.170
George Mulhearn: Yes, yeah.

478
00:43:26.670 --> 00:43:29.459
George Mulhearn: yeah, yeah, it's interesting.

479
00:43:34.560 --> 00:43:39.759
George Mulhearn: Yeah, I guess I guess it needs more thought about the the Async method handling.

480
00:43:42.970 --> 00:43:50.730
Bogdan Mircea: Yeah, I mean, ultimately, I think Patrick is right. I probably at some point. If they don't already, or they don't have it planned. Even

481
00:43:52.160 --> 00:43:54.839
Bogdan Mircea: they're probably going to support it because it's a it's a big thing.

482
00:43:56.630 --> 00:43:59.100
Bogdan Mircea: and that would be that would be really really cool.

483
00:44:00.250 --> 00:44:07.520
George Mulhearn: Yeah, yeah, i'll need to have a browse through the community discussion. I'm sure they will have talked about it a lot.

484
00:44:07.910 --> 00:44:09.770
But yeah.

485
00:44:10.920 --> 00:44:24.670
Patrik Stas: I mean other than that. It really looks cool. So it's it's awesome. I I apart from other than the Async. I guess the the that, I think, is the only thing in like, only

486
00:44:24.680 --> 00:44:42.949
Patrik Stas: the at a tribute or part where where Libya 6 it's current state. This unlike, has advantage. But I mean, this is amazing, as you can generate all the rappers for all, for what I you mentioned number of languages right, Java Ios python.

487
00:44:44.290 --> 00:45:04.079
Patrik Stas: So that's that's pretty cool. I mean there's lots of code we currently have to maintain. If you want to make it changes to a would be 6 like if a. By interface. And there's like 3 other places we need to update things. So this this is amazing that you can. We can do this all just do it once and have it everywhere.

488
00:45:04.830 --> 00:45:18.490
George Mulhearn: Yeah, yeah, it's pretty pretty cool. I was gonna show you this as well. So all the all the structs, all the impulse, have a destroy method attached to them, and I guess I I Haven't seen this before, but

489
00:45:20.240 --> 00:45:25.600
George Mulhearn: this looks like it's doing the the freeing of the reference counter, which

490
00:45:25.640 --> 00:45:26.919
George Mulhearn: in turn would.

491
00:45:27.700 --> 00:45:30.939
George Mulhearn: I guess, free of the memory in rust and drop it.

492
00:45:31.570 --> 00:45:33.960
Bogdan Mircea: So maybe this is something.

493
00:45:34.480 --> 00:45:38.070
Bogdan Mircea: Yeah, it looks like it's simulating what the arc is doing

494
00:45:38.310 --> 00:45:40.969
Bogdan Mircea: because it has the internal reference counter

495
00:45:41.530 --> 00:45:45.549
Bogdan Mircea: and assume that once that reach 0, it actually frees

496
00:45:45.980 --> 00:45:47.129
Bogdan Mircea: the memory.

497
00:45:48.350 --> 00:45:49.080
George Mulhearn: Yeah.

498
00:45:49.150 --> 00:45:51.250
Bogdan Mircea: is this all reference counter?

499
00:45:51.310 --> 00:45:56.590
Bogdan Mircea: But i'm actually that was maybe a different question. You mentioned the beginning something about the

500
00:45:56.770 --> 00:46:04.010
Bogdan Mircea: like when crossing the Ffi boundaries. That types must be sent in sync. And you're wrapping the connection. I believe in an arc.

501
00:46:04.520 --> 00:46:06.180
Bogdan Mircea: I don't know if I remember correctly.

502
00:46:06.570 --> 00:46:12.720
George Mulhearn: Yeah, yeah, they they force you to, I guess, pass structs through as if they are

503
00:46:15.700 --> 00:46:26.109
George Mulhearn: so. For example, this constructor in the udl. It says, you know there's no arc around it, but unify

504
00:46:26.540 --> 00:46:30.389
George Mulhearn: what unified does as well is it generates out.

505
00:46:30.700 --> 00:46:31.790
George Mulhearn: I guess

506
00:46:32.390 --> 00:46:37.240
George Mulhearn: it generates out rus code which is exposed in your binary.

507
00:46:37.330 --> 00:46:38.540
That

508
00:46:38.650 --> 00:46:40.569
George Mulhearn: is what the the the

509
00:46:42.140 --> 00:46:48.409
George Mulhearn: yeah is what the rapper Colin interface ends up calling on to. So

510
00:46:48.630 --> 00:46:53.940
George Mulhearn: that generated Rus code enforces that. You know these things are wrapped in ox.

511
00:46:54.050 --> 00:46:55.630
which is why

512
00:46:55.710 --> 00:46:58.799
George Mulhearn: you can see, i'm having to return them as a

513
00:47:00.920 --> 00:47:02.030
Bogdan Mircea: not for still.

514
00:47:02.860 --> 00:47:07.140
Bogdan Mircea: Okay, I mean, I guess it makes sense that if you want to interface with the

515
00:47:07.380 --> 00:47:11.050
Bogdan Mircea: the language that uses reference counting

516
00:47:11.560 --> 00:47:14.090
Bogdan Mircea: probably be the way to do it.

517
00:47:14.300 --> 00:47:18.390
Bogdan Mircea: What i'm also curious about is how they handle mutability, though.

518
00:47:19.660 --> 00:47:22.840
Bogdan Mircea: like.

519
00:47:23.440 --> 00:47:24.180
Bogdan Mircea: Okay.

520
00:47:24.880 --> 00:47:29.709
George Mulhearn: Yeah. So that that's why I've had to wrap it in this mutex.

521
00:47:29.800 --> 00:47:31.130
Bogdan Mircea: And then I can.

522
00:47:31.240 --> 00:47:37.430
George Mulhearn: These functions get the Mutex and then mutate it and then store it again.

523
00:47:38.330 --> 00:47:39.229
Bogdan Mircea: I see.

524
00:47:39.410 --> 00:47:40.140
Bogdan Mircea: Okay.

525
00:47:40.440 --> 00:47:41.780
George Mulhearn: for example, this year.

526
00:47:43.640 --> 00:47:46.980
Bogdan Mircea: Yeah. So you basically have to enforce that in your rust codes

527
00:47:47.170 --> 00:47:48.590
Bogdan Mircea: so that

528
00:47:48.970 --> 00:47:52.849
Bogdan Mircea: nothing crashes when you cross the by boundary.

529
00:47:53.080 --> 00:47:54.860
George Mulhearn: Yeah, exactly. Yeah.

530
00:47:54.990 --> 00:47:55.889
Bogdan Mircea: Fair enough.

531
00:47:56.580 --> 00:48:01.500
George Mulhearn: yeah. Yeah. And the other cool part as well is that it does a pretty good job of

532
00:48:01.670 --> 00:48:05.320
George Mulhearn: wrapping your errors as well, so you can see

533
00:48:05.640 --> 00:48:09.149
George Mulhearn: I've created this very basic

534
00:48:09.190 --> 00:48:12.760
George Mulhearn: error type, and it supports this error.

535
00:48:12.960 --> 00:48:16.140
George Mulhearn: And then in Udl that's exposed as

536
00:48:16.770 --> 00:48:17.700
George Mulhearn: this here

537
00:48:18.570 --> 00:48:23.959
George Mulhearn: and then methods which return a result mocked as as throwable.

538
00:48:30.260 --> 00:48:32.669
George Mulhearn: and then in the generated code

539
00:48:33.230 --> 00:48:37.589
George Mulhearn: you can see it's generated out the exception classes.

540
00:48:37.840 --> 00:48:39.889
George Mulhearn: so it'll

541
00:48:39.990 --> 00:48:43.340
George Mulhearn: throw and pass through these different exception types.

542
00:48:43.710 --> 00:48:44.709
George Mulhearn: Into

543
00:48:44.760 --> 00:48:50.739
George Mulhearn: this Scotland code. You can pass through messages as well to give more details, etc.

544
00:48:51.740 --> 00:48:52.370
Bogdan Mircea: Cool.

545
00:48:52.470 --> 00:48:56.250
Bogdan Mircea: Yeah, I've seen your as part. That's actually really cool. They didn't map them

546
00:48:56.300 --> 00:48:57.390
Bogdan Mircea: fairly well.

547
00:48:57.760 --> 00:48:58.319
George Mulhearn: Hmm.

548
00:48:58.680 --> 00:48:59.810
Bogdan Mircea: Really interesting.

549
00:49:03.100 --> 00:49:05.939
George Mulhearn: Cool. That's all I had to show

550
00:49:07.210 --> 00:49:26.239
Patrik Stas: awesome. Thank you, George. I was really well prepared, and I mean the the the code is nice, and you even started the application the only a all over the expectations for this demo. I didn't thought we actually gonna see like working android, and we'll emulate the demo. So it's really well done.

551
00:49:26.480 --> 00:49:30.839
George Mulhearn: Yeah. Well, you never know if it's working until you put it in a map, you know.

552
00:49:30.860 --> 00:49:32.789
Patrik Stas: Yeah, that's right.

553
00:49:32.840 --> 00:49:38.899
Yeah. But I guess let's let's move on to the like next part. And I guess just

554
00:49:39.260 --> 00:49:57.679
Patrik Stas: the end meeting discussion about the the State machine. But state pattern and serialization. And but before we dig into it, I would like to just ask you if you are okay, going a little bit over the you know the official

555
00:49:57.690 --> 00:50:05.919
meeting minutes. Let's say if we stretch it out to 10min, 10 or 15min extra. Are you? Are you guys? Okay? With that

556
00:50:07.060 --> 00:50:08.090
Bogdan Mircea: it's cool for me.

557
00:50:08.380 --> 00:50:17.050
Patrik Stas: Yeah, yeah, Cool for me. Yeah, I I feel like we need more than 10min for this. So just so we we we get it. We get that

558
00:50:17.430 --> 00:50:21.850
Patrik Stas: kind of cleared up ahead of time. So yeah.

559
00:50:22.320 --> 00:50:31.689
Patrik Stas: now, yeah, where to start? I'm not sure. I guess i'll just like brief intra, although you are aware of what's going on

560
00:50:32.050 --> 00:50:35.330
Patrik Stas: for the sake of the meeting and the recording.

561
00:50:35.350 --> 00:50:56.539
Patrik Stas: there was a so there! There's a discussion about serialization, and and it's approach and philosophy. So the way this whole thing started mainly is by making this new board, you know, implementing the new approach with the type, state connections

562
00:50:56.810 --> 00:50:59.170
and by book done.

563
00:50:59.190 --> 00:51:04.560
Patrik Stas: And and I saw this as a portrait to

564
00:51:04.760 --> 00:51:10.699
Patrik Stas: fix inefficiencies or like weaknesses in the serialization

565
00:51:10.870 --> 00:51:14.220
Patrik Stas: format we currently have.

566
00:51:14.460 --> 00:51:25.459
Patrik Stas: And I thought, oh, we can now do a bunch of other. Since we are making breaking change on this connection, Steve machine, we can introduce a bunch of other breaking changes

567
00:51:25.580 --> 00:51:28.299
at at this opportunity, and we can

568
00:51:28.460 --> 00:51:31.549
Patrik Stas: come up with a new, better format.

569
00:51:31.770 --> 00:51:43.130
Patrik Stas: And then this also relates to this this, this this thought. They're also triggered by by issue with George created few days last week

570
00:51:44.920 --> 00:51:59.819
Patrik Stas: about about using from parts and 2 parts methods which are defined on medieval connections, but not on others. And apparently George found this concerned useful. And

571
00:51:59.830 --> 00:52:11.260
Patrik Stas: here, in these issues being suggested that we adopt the same sort of methods or pattern for the other State machines as well. Now, then.

572
00:52:11.360 --> 00:52:26.009
Patrik Stas: then, this kind of took us to some of the discussions we had until now internally with Bogdan and me about the actual philosophy of serialization, where

573
00:52:27.880 --> 00:52:29.640
Patrik Stas: where

574
00:52:29.720 --> 00:52:33.499
Patrik Stas: we're thinking whether the format

575
00:52:33.510 --> 00:52:55.800
Patrik Stas: should be simply, it's completely up to the consumers, and it should be just internal, you know, internal matter of as DC. And and and therefore we should actually be quite clear about the fact that you should not rely on what the serialized

576
00:52:55.810 --> 00:52:57.669
Patrik Stas: State mission looks like.

577
00:52:57.740 --> 00:53:04.000
Patrik Stas: This format can change, and it's not meant for sort of direct consumption.

578
00:53:04.940 --> 00:53:15.549
Patrik Stas: So that's kind of the intro. No. So maybe we can start. Since since George, you created this issue. In the first place, maybe you can give some, you know.

579
00:53:15.740 --> 00:53:20.939
Patrik Stas: background or like, kick off the discussion about what you are trying to do, and then

580
00:53:21.100 --> 00:53:22.709
Patrik Stas: we can take it from there.

581
00:53:23.780 --> 00:53:26.299
George Mulhearn: Yeah, yeah, sure. Thanks. So

582
00:53:26.500 --> 00:53:36.309
George Mulhearn: yeah, I was. I was working with the connection handler, at least in its old state and recently in the type State version.

583
00:53:36.400 --> 00:53:37.509
George Mulhearn: And

584
00:53:38.250 --> 00:53:43.369
George Mulhearn: basically it seems at the moment that the only way that you can, you know.

585
00:53:43.500 --> 00:53:46.350
George Mulhearn: take a Area's Vcx connection.

586
00:53:46.400 --> 00:53:51.789
George Mulhearn: and then turn it into something that you can store in your own database or something of that effect.

587
00:53:51.880 --> 00:54:03.390
George Mulhearn: and then later fetch it from your database and reconstruct it into that Aries Vcx connection. The only way to do that at the moment is by using serializer methods.

588
00:54:05.130 --> 00:54:14.979
George Mulhearn: That. And that's because there's no way to, I guess Manually construct the connection handler with data that you have yourself.

589
00:54:17.240 --> 00:54:19.330
George Mulhearn: And so I guess

590
00:54:19.620 --> 00:54:24.419
George Mulhearn: the problem I have with that being the only way to do it is.

591
00:54:24.790 --> 00:54:31.299
George Mulhearn: I guess, the state of the connection handler being serialized and be serialized isn't

592
00:54:31.680 --> 00:54:37.049
George Mulhearn: extremely stable, at least at the moment. So I guess

593
00:54:37.080 --> 00:54:44.350
George Mulhearn: there's no guarantee that if I were to serialize a connection now and then store that string in my database. And then.

594
00:54:44.460 --> 00:54:48.839
George Mulhearn: you know, 2 years later on, on a newer version of Vcx. Try to

595
00:54:48.900 --> 00:54:51.180
George Mulhearn: deserialize that

596
00:54:51.450 --> 00:54:55.400
George Mulhearn: back into the connection, handler. There's no guarantee that it would

597
00:54:55.610 --> 00:54:56.899
George Mulhearn: be successful.

598
00:54:59.260 --> 00:55:10.149
George Mulhearn: Yeah. And and so because there's not that guarantee. And also just because, in my opinion, it's best practice to store data in your own format rather than

599
00:55:10.260 --> 00:55:14.389
George Mulhearn: relying on a a third parties serialization

600
00:55:14.540 --> 00:55:15.439
George Mulhearn: method.

601
00:55:15.490 --> 00:55:18.759
George Mulhearn: at least from a Vcx consumer standpoint

602
00:55:18.980 --> 00:55:25.199
George Mulhearn: it. It'd be better if there was a way to construct up the connection handler using.

603
00:55:25.230 --> 00:55:31.869
George Mulhearn: you know, raw data using your invitation message and your did, Doc, You know those are

604
00:55:31.920 --> 00:55:34.590
George Mulhearn: di primitives, in a sense.

605
00:55:36.510 --> 00:55:43.080
George Mulhearn: So yeah, that's why I was proposing that the from parts handle the the front parts method of connection should be

606
00:55:43.500 --> 00:55:45.770
George Mulhearn: a a a public Api.

607
00:55:47.970 --> 00:55:57.370
Patrik Stas: So basically. You like, yeah, I I I get it like if you have, if you have did do. And if you have some key par pairwise keys

608
00:55:57.530 --> 00:55:58.909
Patrik Stas: for the big talk

609
00:55:58.970 --> 00:56:09.519
Patrik Stas: that's actually that that represents some sort of did come communication channel. And you want to create the connection object from the connection handler from that.

610
00:56:11.150 --> 00:56:17.489
George Mulhearn: Yeah, yeah. Exactly. So I I guess if you imagine your consumer of the Vcx.

611
00:56:17.580 --> 00:56:18.540
George Mulhearn: you

612
00:56:18.680 --> 00:56:23.630
George Mulhearn: you're an invite. I say, you're an invider, and you generate the invitation and send it out.

613
00:56:23.700 --> 00:56:28.360
George Mulhearn: Now you'd want to take that connection, handler and

614
00:56:28.460 --> 00:56:38.170
George Mulhearn: turn it into your own bits of data. So you know you'd still your did dock, your pay, wise keys, the invitation you generate, you'd

615
00:56:38.360 --> 00:56:41.890
George Mulhearn: take that and store it away in your own database, and then.

616
00:56:41.920 --> 00:56:46.880
George Mulhearn: when you get the request message back from the P that you're connecting with.

617
00:56:46.980 --> 00:56:50.390
George Mulhearn: Then you can, you know, fetch it from your database, and

618
00:56:50.580 --> 00:56:53.920
George Mulhearn: you know, Take that. Did Doc. That invitation method

619
00:56:54.000 --> 00:57:00.210
George Mulhearn: message and turn it back into the connection handle that you had originally. And then you can, you know.

620
00:57:00.360 --> 00:57:04.499
George Mulhearn: Dot, accept, request, or whatever the method is to take the next step.

621
00:57:04.760 --> 00:57:07.380
George Mulhearn: and then you can store it away again. Bring it back.

622
00:57:09.820 --> 00:57:13.500
George Mulhearn: Yeah, that that's the idea rather than relying on serialization

623
00:57:15.640 --> 00:57:19.029
Patrik Stas: book Done? What? What's your take? And the response

624
00:57:19.690 --> 00:57:21.020
stuff

625
00:57:21.740 --> 00:57:22.840
Bogdan Mircea: I mean

626
00:57:23.160 --> 00:57:24.180
Bogdan Mircea: so

627
00:57:24.250 --> 00:57:30.229
Bogdan Mircea: honestly. The the selling point that George had in one of his comments was about the fact that.

628
00:57:30.280 --> 00:57:32.329
Bogdan Mircea: regardless of what you do.

629
00:57:32.500 --> 00:57:37.299
Bogdan Mircea: people will still be able to manipulate the connection in its serialized state.

630
00:57:37.330 --> 00:57:43.710
Bogdan Mircea: and then modify that. Let's say it's adjacent string, and then serialize it back to a different state.

631
00:57:43.810 --> 00:57:46.469
Bogdan Mircea: But my take honestly would be that

632
00:57:46.910 --> 00:58:00.710
Bogdan Mircea: this is, in my view, sort of looking for trouble like arbitrarily modifying a connection which is part like a connection state as part of a protocol which should be followed. Let's say strictly.

633
00:58:02.300 --> 00:58:12.030
Bogdan Mircea: and then deconstructing that and constructing it back is not something that I would personally do or advice doing in terms of

634
00:58:12.950 --> 00:58:25.370
Bogdan Mircea: like the stability of the of the serialized format. I think that even when we let's say, let's say we merge this type, state connection, and a year from now we change the serialization format. We could accommodate

635
00:58:25.760 --> 00:58:28.490
the deserialization to

636
00:58:28.910 --> 00:58:31.889
try both the old and the new format, so that

637
00:58:32.320 --> 00:58:43.930
Bogdan Mircea: we can sort of ensure backwards compatibility in that regard. It wouldn't be too difficult and more costly, and then ultimately, the old format would get deprecated at some point.

638
00:58:46.690 --> 00:58:48.319
Bogdan Mircea: And

639
00:58:48.520 --> 00:58:55.520
Bogdan Mircea: yeah, I mean like, if it weren't for the possibility of someone modifying the serialized format.

640
00:58:55.580 --> 00:58:58.279
Bogdan Mircea: I would honestly be against

641
00:58:58.300 --> 00:58:59.439
these

642
00:58:59.560 --> 00:59:02.649
Bogdan Mircea: public methods of from parts and into parts. I think

643
00:59:02.810 --> 00:59:04.470
Bogdan Mircea: that the protocol

644
00:59:05.460 --> 00:59:10.330
Bogdan Mircea: should be followed strictly without shortcuts, or

645
00:59:10.560 --> 00:59:12.680
Bogdan Mircea: I don't know alternatives like this.

646
00:59:13.130 --> 00:59:14.109
Bogdan Mircea: But

647
00:59:14.340 --> 00:59:17.149
Bogdan Mircea: I guess the other reason

648
00:59:17.980 --> 00:59:19.940
Bogdan Mircea: might be that

649
00:59:20.560 --> 00:59:29.210
Bogdan Mircea: I don't know if you want to. If you want to migrate from a different agent implementation which might store things differently, and you ultimately end up having the same parts, so

650
00:59:29.330 --> 00:59:36.389
Bogdan Mircea: you could just take those parts and then migrate to the the as B. Cx implementation.

651
00:59:36.790 --> 00:59:43.249
Bogdan Mircea: So that would be, I guess one good use case. I don't think it would happen too often, but still

652
00:59:45.730 --> 00:59:48.010
Bogdan Mircea: and mirror. I have an idea about these.

653
00:59:48.110 --> 00:59:50.839
Bogdan Mircea: Let's say, let's hold them. These raw methods

654
00:59:52.770 --> 01:00:00.079
Bogdan Mircea: to be behind a a feature flag or something like that, so that they wouldn't necessarily be directly accessible, and people would be

655
01:00:00.460 --> 01:00:04.950
Bogdan Mircea: Let's say, to use them with caution.

656
01:00:05.270 --> 01:00:06.850
Bogdan Mircea: Hmm.

657
01:00:08.030 --> 01:00:15.819
Bogdan Mircea: Yeah, I mean, I guess like that's the way I I would do it. I would implement them behind the feature flag.

658
01:00:16.080 --> 01:00:17.370
Bogdan Mircea: And

659
01:00:17.800 --> 01:00:22.420
Bogdan Mircea: yeah advice people to use them if they really really really need to.

660
01:00:24.190 --> 01:00:27.440
Bogdan Mircea: And I guess it's also in the in the view of

661
01:00:28.840 --> 01:00:32.329
Bogdan Mircea: kind of helping them not mess things up because

662
01:00:32.380 --> 01:00:35.459
Bogdan Mircea: you can theoretically do it right now

663
01:00:35.550 --> 01:00:44.759
Bogdan Mircea: with the current implementation of the types they connection. Like. Even without these methods, you can serialize into something, build the replica like how the replica of the

664
01:00:44.790 --> 01:00:51.900
Bogdan Mircea: connection and the serialize into that, and then take the take that split that apart into parts

665
01:00:52.110 --> 01:00:55.290
Bogdan Mircea: and smaller pieces, and then store them, or whatever

666
01:00:56.930 --> 01:01:10.610
Patrik Stas: I I i'll just point out, I guess, like on George's point about like relying. You know, the 2 years down the road relying on the format of

667
01:01:10.920 --> 01:01:12.319
Patrik Stas: the Vcx.

668
01:01:14.140 --> 01:01:16.019
Patrik Stas: Like. If you're gonna.

669
01:01:16.170 --> 01:01:24.209
Patrik Stas: I guess if you're gonna like dissect connection in this kind of fashion like you basically take connection and you generate

670
01:01:24.260 --> 01:01:32.390
Patrik Stas: like, I know there's few things right there to some some connection state. And third, Id and some Paradise info.

671
01:01:32.520 --> 01:01:34.069
maybe something else

672
01:01:34.360 --> 01:01:39.500
Patrik Stas: in in some way. You're still relying, I guess, on the way

673
01:01:39.810 --> 01:01:43.480
Patrik Stas: that you know. How is this serializing?

674
01:01:43.800 --> 01:01:44.620
Patrik Stas: But

675
01:01:45.310 --> 01:01:50.899
Patrik Stas: you know what I mean like. I guess the the the risk kind of which you

676
01:01:51.200 --> 01:01:54.529
Patrik Stas: very afraid of. I guess it's still there, because

677
01:01:55.040 --> 01:02:00.470
Patrik Stas: 2 years later, this 2 years later, this must still serialize into the same thing

678
01:02:01.060 --> 01:02:03.340
Patrik Stas: as it is as it is today.

679
01:02:04.520 --> 01:02:08.779
George Mulhearn: Yeah, yeah, I see a point. So I guess on that.

680
01:02:09.150 --> 01:02:13.949
George Mulhearn: I I've been playing around with the the type State branch where I've made the

681
01:02:14.200 --> 01:02:19.239
George Mulhearn: from Pots method public. Just so I could test a few things

682
01:02:19.480 --> 01:02:25.940
George Mulhearn: when the from Pots method is public. You're able to basically reconstruct connections with

683
01:02:26.210 --> 01:02:33.829
George Mulhearn: the base data. So it did dock invitation, message, request, message, etc. Thread Id

684
01:02:33.920 --> 01:02:35.359
So

685
01:02:35.970 --> 01:02:45.569
George Mulhearn: I I guess what I would consider best practice is if a. V. 6 consumer is storing that data themselves and in whatever format they wish, and then they can.

686
01:02:45.840 --> 01:02:50.050
George Mulhearn: you know, construct the invitation method, message and threat. Id

687
01:02:50.150 --> 01:02:53.250
George Mulhearn: and then plug that into the from Pods method.

688
01:02:55.100 --> 01:02:57.379
George Mulhearn: Yeah. So they don't have to rely on any

689
01:02:57.490 --> 01:03:01.359
George Mulhearn: Vcx Specific serialization formats

690
01:03:04.950 --> 01:03:07.959
Bogdan Mircea: well. The format is not necessarily

691
01:03:08.010 --> 01:03:10.110
Bogdan Mircea: setting stone. It's the

692
01:03:10.810 --> 01:03:13.620
Bogdan Mircea: I guess the realization method that's set in stone.

693
01:03:14.060 --> 01:03:17.620
Bogdan Mircea: The format could be Jason or Ben Code, or anything you want

694
01:03:17.990 --> 01:03:19.370
Bogdan Mircea: Right? Right?

695
01:03:20.110 --> 01:03:30.370
Patrik Stas: The the the idea I like we had discussions with with, and the the idea, and I tend to I I

696
01:03:30.390 --> 01:03:34.059
Patrik Stas: i'm i'm rather convinced. Now

697
01:03:34.780 --> 01:03:50.140
Patrik Stas: this is following the philosophy. I guess I guess there's like actually like 2 issues here, and i'm gonna use draw. I because I love diagrams and visual visualizing ideas. So

698
01:03:50.210 --> 01:03:54.559
Patrik Stas: let's say you have a connection, some sort of connection object.

699
01:03:54.760 --> 01:04:16.729
Patrik Stas: whether it's the old handler or the like. The new type state connection. And and then, I guess, like one thing is what George wants right is like having this some sort of Api which enables you to dissect the connection into multiple things. So, like some state data, and

700
01:04:16.740 --> 01:04:19.430
Patrik Stas: the dog maybe, and

701
01:04:19.470 --> 01:04:22.059
Patrik Stas: I don't know.

702
01:04:23.290 --> 01:04:26.820
Patrik Stas: and then and then, like the

703
01:04:27.160 --> 01:04:35.239
Patrik Stas: and the approach with like serialize. So this will be from parts, from 2

704
01:04:37.220 --> 01:04:46.509
Patrik Stas: arts. That's like one thing. And so questions like, do. Should we have the, or should we not have it.

705
01:04:46.830 --> 01:04:57.479
Patrik Stas: And then, or should it be behind feature flight, and then the other like issue or question discussion. Point is about the serialize, the serialize

706
01:04:57.560 --> 01:05:05.469
Patrik Stas: which we currently have, and I think we we gonna keep it.

707
01:05:05.500 --> 01:05:10.880
Patrik Stas: because I mean the removing. It will be like really a huge change

708
01:05:11.290 --> 01:05:15.440
Patrik Stas: for everyone. So the current approach

709
01:05:16.100 --> 01:05:17.380
Patrik Stas: I like with them

710
01:05:17.520 --> 01:05:26.280
Patrik Stas: what's on the main branch right now is yeah, that we generally the Syria, like serialize

711
01:05:26.410 --> 01:05:29.440
Patrik Stas: into some sort of Jason.

712
01:05:29.590 --> 01:05:36.889
So this is data, and there's like the State and like invite her blah, blah, blah, blah, blah!

713
01:05:37.130 --> 01:05:39.220
Patrik Stas: I may be paralyzing for

714
01:05:40.030 --> 01:05:41.399
Patrik Stas: otherwise insult.

715
01:05:42.380 --> 01:05:47.180
Patrik Stas: and it's like generally the key.

716
01:05:49.900 --> 01:05:52.930
Patrik Stas: and it's like.

717
01:05:52.950 --> 01:05:55.189
Patrik Stas: generally speaking.

718
01:05:55.330 --> 01:05:59.850
Patrik Stas: like easy to look at and bars, and

719
01:06:00.090 --> 01:06:01.850
Patrik Stas: and

720
01:06:02.090 --> 01:06:04.429
Patrik Stas: it's easy to make me well.

721
01:06:04.650 --> 01:06:08.479
Patrik Stas: It's easy for people currently

722
01:06:08.720 --> 01:06:28.640
Patrik Stas: to fall into pattern where they actually start relying on this in this structure of the serialized data and the the philosophy, the idea bog done was proposed, like main proponent of, and and, as I mentioned, I tend to agree

723
01:06:28.800 --> 01:06:36.470
Patrik Stas: with with his suggestion now is that we should make it like. We completely go back

724
01:06:36.620 --> 01:06:42.569
Patrik Stas: to the to the user so the user shouldn't by any meet, any

725
01:06:43.280 --> 01:06:53.239
Patrik Stas: chance, you know, attempt to rely on what this Jason looks like, and instead, he should just consider it the black box like oh.

726
01:06:53.510 --> 01:06:59.070
Patrik Stas: it's some sort of string, you know, or some sort of binary format or whatever.

727
01:07:00.410 --> 01:07:14.420
Patrik Stas: So so that's the kind of yeah 2, I guess 2 2 issues here. That does this make sense, George and Logan is this: do you think? Is this re clearly representing the discussion we are heading

728
01:07:15.810 --> 01:07:16.960
Bogdan Mircea: in? The

729
01:07:18.000 --> 01:07:19.169
Patrik Stas: Yeah.

730
01:07:19.260 --> 01:07:24.410
Patrik Stas: Okay. And so, then, then the the question is.

731
01:07:25.130 --> 01:07:29.489
Patrik Stas: then the question is, should we

732
01:07:30.070 --> 01:07:37.249
Patrik Stas: given the like new approach, and maybe the new philosophy where we want to.

733
01:07:37.260 --> 01:07:52.360
Patrik Stas: as it's booked on said settings to the serialized and the serialized methods as a contract like, or if you use, if you serialize something, we will give you a guarantee that you'll be able to dissurilize it. But but

734
01:07:52.410 --> 01:07:55.589
Patrik Stas: consider the serialized data as a black box.

735
01:07:55.930 --> 01:07:58.360
Given this approach.

736
01:07:58.520 --> 01:08:03.160
Patrik Stas: and this like kind of contract or promise here.

737
01:08:03.210 --> 01:08:18.689
Patrik Stas: Do you think, George, you would like still need or want this? This, this approach, or I mean ideally, there will be like one canonical way of doing things, and it will do less code to maintain. But, on the other hand, I don't know. Maybe

738
01:08:18.850 --> 01:08:23.399
Patrik Stas: it is something we really want to have, because we can. We can still consider it.

739
01:08:25.060 --> 01:08:39.619
George Mulhearn: Yeah, I I guess. Yeah, I get what you mean by the If you have a guarantee, then it could solve the problem. I I don't know. It is still my opinion that it's generally best practice to

740
01:08:39.979 --> 01:08:41.090
George Mulhearn: store

741
01:08:41.710 --> 01:08:44.779
George Mulhearn: data in in your own format

742
01:08:45.760 --> 01:08:48.879
George Mulhearn: rather than rely on a third party format

743
01:08:49.210 --> 01:08:51.039
George Mulhearn: from a consumer point of view.

744
01:08:55.319 --> 01:08:59.809
George Mulhearn: Yeah. But I guess if you guys disagree that that's okay.

745
01:09:00.229 --> 01:09:05.280
George Mulhearn: But yeah, I I think i'll be skating. This serialization format is a is a good idea.

746
01:09:05.350 --> 01:09:11.660
George Mulhearn: Stops people from trying to replicate the connection and then change the data manually themselves.

747
01:09:14.880 --> 01:09:16.769
Bogdan Mircea: Yeah, I think in the end, like

748
01:09:16.930 --> 01:09:20.170
Bogdan Mircea: I assume that's the main goal of the protocol.

749
01:09:20.279 --> 01:09:22.639
Bogdan Mircea: and especially the

750
01:09:22.939 --> 01:09:23.750
Bogdan Mircea: I just

751
01:09:23.810 --> 01:09:25.059
Bogdan Mircea: 5 state

752
01:09:25.229 --> 01:09:31.639
Bogdan Mircea: pattern approach of having things run in a strict way, so to say, so that

753
01:09:32.050 --> 01:09:34.309
Bogdan Mircea: you don't end up making mistakes

754
01:09:34.590 --> 01:09:35.939
Bogdan Mircea: and

755
01:09:36.640 --> 01:09:39.659
Bogdan Mircea: giving people more access to

756
01:09:40.109 --> 01:09:42.019
Bogdan Mircea: stuff that they can break

757
01:09:43.790 --> 01:09:46.170
might not necessarily be a good idea.

758
01:09:49.220 --> 01:09:52.789
Bogdan Mircea: I I honestly don't know I mean I i'm not trying to say that

759
01:09:54.029 --> 01:09:57.800
Bogdan Mircea: I know we shouldn't do it, or that it's a bad idea.

760
01:09:57.850 --> 01:10:04.049
Bogdan Mircea: I just think that there is a very narrow use case for stuff like this, and it can still be done

761
01:10:04.220 --> 01:10:06.819
if you really need to.

762
01:10:07.230 --> 01:10:11.239
Indeed. You have to like. Build your replicas and stuff like that.

763
01:10:14.990 --> 01:10:19.049
Bogdan Mircea: I don't know, and replicas can up being out of sync

764
01:10:19.080 --> 01:10:22.089
Bogdan Mircea: like I don't know if the serialization format changes.

765
01:10:22.210 --> 01:10:29.290
Bogdan Mircea: But I guess this is also the reason why we wouldn't necessarily advice to use this kind of approach.

766
01:10:31.580 --> 01:10:36.010
Bogdan Mircea: Because, yeah, then things will break or might break.

767
01:10:36.190 --> 01:10:39.370
Patrik Stas: How about about this? How about

768
01:10:43.740 --> 01:10:50.430
Patrik Stas: How about the state machines? You know the the the state machines, or these handlers, or these objects

769
01:10:50.700 --> 01:10:59.579
Patrik Stas: they wouldn't necessarily. They wouldn't actually be serializable. We wouldn't declare, you know, serial, that serializable on it. We wouldn't derive it

770
01:10:59.610 --> 01:11:04.260
Patrik Stas: What we instead. Would do. If we have this, we have this kind of pair of methods

771
01:11:04.580 --> 01:11:08.099
Patrik Stas: which would produce, you know, number of

772
01:11:08.320 --> 01:11:11.820
Patrik Stas: building blocks, some components of the connections

773
01:11:12.030 --> 01:11:18.290
Patrik Stas: of the connection which are serializable. So everything returned here. Each of these parts.

774
01:11:18.460 --> 01:11:20.369
as we speak.

775
01:11:20.390 --> 01:11:22.439
would be serializable.

776
01:11:22.480 --> 01:11:24.750
Patrik Stas: and it it wouldn't be

777
01:11:24.800 --> 01:11:30.719
Patrik Stas: at all a concern of how to. You know serialize things.

778
01:11:30.930 --> 01:11:46.089
Patrik Stas: I'll. I'll do see, relax connection, and and it now, when I come to think about it, it's it's very opinionated that you know we do it to string, and it's in it's Jason, like Why should it be hard? Coded in a. Is V. 6? On the other hand, we we want to

779
01:11:46.120 --> 01:12:02.519
Patrik Stas: keep the maintain the Liberty 6 contract, so we we don't want to like, Go completely like crazy, and make something completely new, and we want to preserve the interfaces. So, instead

780
01:12:02.810 --> 01:12:05.810
Patrik Stas: instead of having this in

781
01:12:06.020 --> 01:12:07.969
a

782
01:12:08.650 --> 01:12:12.169
Patrik Stas: let me do some swim lines here.

783
01:12:12.260 --> 01:12:15.380
Patrik Stas: let me do like this is

784
01:12:17.810 --> 01:12:24.990
Bogdan Mircea: i'm going to understand that we don't enforce any serialization format in as Vcx

785
01:12:25.890 --> 01:12:30.879
Bogdan Mircea: implementing the serialized trade only allows the serialize them to anything

786
01:12:31.400 --> 01:12:33.300
Bogdan Mircea: they don't have to be Jason.

787
01:12:34.240 --> 01:12:39.550
Patrik Stas: Oh, yeah, that that's right. That's that's true. But yeah.

788
01:12:40.220 --> 01:12:59.439
Patrik Stas: Well, where I was heading. Well, maybe I'm: I'm: i'm wrong. But i'll just finish my original idea kind of. Maybe it's it's like technically slight, slightly wrong, or you can correct it or it right only. But the idea it was that the the kind of main interface would be like. Oh, you can. You can dissect this this

789
01:12:59.700 --> 01:13:01.970
Patrik Stas: State machines into some like

790
01:13:02.130 --> 01:13:04.179
Patrik Stas: reasonable chunks of

791
01:13:04.990 --> 01:13:12.320
Patrik Stas: things which belong together like state data, or maybe the dog or paradise in full, maybe like, yeah.

792
01:13:12.410 --> 01:13:16.960
Patrik Stas: right? Id just some things you typically want to, maybe

793
01:13:18.110 --> 01:13:21.099
Patrik Stas: like, have a separate or access

794
01:13:21.310 --> 01:13:23.960
Patrik Stas: frequently, or kind of deal with it

795
01:13:24.420 --> 01:13:25.760
Patrik Stas: individually.

796
01:13:25.830 --> 01:13:35.510
Patrik Stas: And then yeah. And then this would basically accommodate, like George Need, or people who want to just structure, and

797
01:13:35.860 --> 01:13:51.210
Patrik Stas: this will be like generic enough for any. And they want to like implement any kind of serialization and and organize the data in a way they they desire. And then in a lib cx

798
01:13:52.570 --> 01:13:57.299
Patrik Stas: to the back different color it there's a

799
01:13:58.100 --> 01:14:05.219
Patrik Stas: it's an in in live Vcx: basically that's where we would implement the the sort of

800
01:14:05.690 --> 01:14:08.370
Patrik Stas: that. Take these things together.

801
01:14:09.460 --> 01:14:12.049
Patrik Stas: I know how to draw it, but, like

802
01:14:12.290 --> 01:14:13.589
Patrik Stas: pick some arrow

803
01:14:14.610 --> 01:14:19.790
Patrik Stas: like, put it put it together again. We would use the same sort of methods, maybe.

804
01:14:21.410 --> 01:14:26.159
Patrik Stas: and we would like wire it up together again. And basically

805
01:14:26.660 --> 01:14:37.959
Patrik Stas: yeah, some some connection. We would then serialize into our like opaque string, as you know, following the loop Pcx kind of

806
01:14:38.480 --> 01:14:41.490
Patrik Stas: ideal, like philosophy.

807
01:14:41.810 --> 01:14:53.610
Patrik Stas: And so this way. This would cover both George's case, and we could still do the same things the same way we do them even preserve the same serialization format we have currently, perhaps.

808
01:14:58.230 --> 01:15:01.180
George Mulhearn: Yeah, yeah, see, I see what you mean.

809
01:15:03.250 --> 01:15:05.299
George Mulhearn: Yeah, I I I guess maybe

810
01:15:06.250 --> 01:15:10.959
George Mulhearn: I don't. I'm not sure if it solves a bog. D's main issue

811
01:15:11.190 --> 01:15:11.929
George Mulhearn: with

812
01:15:11.950 --> 01:15:13.800
George Mulhearn: consume is being able to

813
01:15:14.490 --> 01:15:17.579
George Mulhearn: put the connection handler into a strange state

814
01:15:19.990 --> 01:15:21.230
George Mulhearn: by, you know.

815
01:15:21.430 --> 01:15:24.349
George Mulhearn: using from parts with some invalid

816
01:15:24.680 --> 01:15:28.709
Patrik Stas: I I I think, like, I mean.

817
01:15:28.990 --> 01:15:30.310
Patrik Stas: like, if they

818
01:15:31.540 --> 01:15:33.810
Patrik Stas: Oh, like, yeah, I guess it's like

819
01:15:34.420 --> 01:15:40.440
Patrik Stas: granular, a kind of granular access, and you can mess it up. But like.

820
01:15:43.160 --> 01:15:55.249
Patrik Stas: yeah, I guess like 0 responsibility of consumer not to like mean coming like 2 different connections together or something. And yeah, so you can always. There's always ways to mess it up somehow

821
01:15:56.760 --> 01:15:58.760
Patrik Stas: in a database, or

822
01:15:58.800 --> 01:16:04.630
Patrik Stas: I I I wouldn't be personally particularly like concerned about consumers

823
01:16:06.060 --> 01:16:14.830
Patrik Stas: messing up the data, and and if they do like it's it's their problem. It's it's granular. Api. People have it. It gives everyone like lots of power

824
01:16:14.870 --> 01:16:19.040
Patrik Stas: and great power comes a great responsibility.

825
01:16:20.420 --> 01:16:21.679
Patrik Stas: What do you think will be done?

826
01:16:22.390 --> 01:16:25.439
George Mulhearn: Yeah, no, I I I that opinion as well.

827
01:16:25.720 --> 01:16:28.749
George Mulhearn: It is a bit philosophical whether

828
01:16:29.050 --> 01:16:34.860
George Mulhearn: you give users control over things, and they can shoot themselves in the foot, or whether

829
01:16:35.160 --> 01:16:38.260
George Mulhearn: you restrict it and ensure that they

830
01:16:38.430 --> 01:16:40.550
George Mulhearn: don't make mistakes, but

831
01:16:41.090 --> 01:16:43.219
George Mulhearn: sort of take away some of the

832
01:16:43.590 --> 01:16:47.280
George Mulhearn: the freedom that how the users might need.

833
01:16:48.070 --> 01:16:49.010
George Mulhearn: Yeah.

834
01:16:49.420 --> 01:16:51.780
George Mulhearn: not not too sure.

835
01:16:54.310 --> 01:16:55.570
Bogdan Mircea: I don't know. I mean

836
01:16:55.610 --> 01:17:00.199
Bogdan Mircea: Again, from my point of view, we can implement the methods. I wouldn't necessarily

837
01:17:00.300 --> 01:17:07.810
Bogdan Mircea: take away the serialization, industrialization from the connection itself, I think honestly, that's going to be the main way people are going to use it.

838
01:17:09.120 --> 01:17:11.090
and

839
01:17:12.460 --> 01:17:21.110
Bogdan Mircea: if if I don't know there is any need to decompose and recompose the connection, we can just implement the from parts and into parts methods.

840
01:17:21.300 --> 01:17:26.510
Bogdan Mircea: And then, if people really want, they can store these in a different format or whatever.

841
01:17:28.740 --> 01:17:29.380
George Mulhearn: Hmm.

842
01:17:30.110 --> 01:17:39.519
Bogdan Mircea: Yeah. I mean, I I was. I already like when the meeting started. I was sort of already decided that we can implement this

843
01:17:39.970 --> 01:17:45.640
Bogdan Mircea: for the few use cases when people want to do things differently, or

844
01:17:45.850 --> 01:17:47.520
Bogdan Mircea: I don't know.

845
01:17:48.720 --> 01:17:54.360
Bogdan Mircea: Yeah, just have more more control over the the State machine, I guess, with the State machine data.

846
01:17:58.630 --> 01:18:02.250
Bogdan Mircea: Yeah, I guess like the the thing that I would

847
01:18:05.330 --> 01:18:10.310
Bogdan Mircea: like the thing that I would be against would be people relying on the serialized format.

848
01:18:10.730 --> 01:18:22.170
Bogdan Mircea: So yeah, this is your main concern, right? I think that should always be sort of like a black box and a black box is a is a wrong term.

849
01:18:22.200 --> 01:18:34.649
Bogdan Mircea: It's completely visible, but it's just that we do not. We shouldn't guarantee that things will stay the same in that regard, at least not right now. Maybe in the future, when things are really stable, and we.

850
01:18:35.160 --> 01:18:36.510
Bogdan Mircea: I don't.

851
01:18:36.670 --> 01:18:42.950
Bogdan Mircea: decide together that there's absolutely nothing else we can we can do to the connection State machine. Let's say.

852
01:18:43.130 --> 01:18:47.869
Bogdan Mircea: Then, yeah, we can tell people. Yeah, this is going to be the stable format from now on.

853
01:18:48.550 --> 01:18:51.490
Bogdan Mircea: because the protocol is completely implemented. It's

854
01:18:51.830 --> 01:18:55.680
Bogdan Mircea: running smoothly. It has everything we wanted to have.

855
01:18:55.820 --> 01:18:57.010
Bogdan Mircea: and that's it.

856
01:18:57.260 --> 01:19:06.409
Bogdan Mircea: Right now I think there's still room for improvement. So that's why I would keep. And I would be reserved about making

857
01:19:06.550 --> 01:19:07.849
Bogdan Mircea: such a promise.

858
01:19:08.500 --> 01:19:09.660
George Mulhearn: Yeah, yeah.

859
01:19:12.180 --> 01:19:19.289
Patrik Stas: George, You, I guess you are okay with that, because you are not even using. And you do this

860
01:19:20.030 --> 01:19:25.859
Patrik Stas: serialization yourself, right? So this is not really something of concern. You concerns you too much.

861
01:19:26.740 --> 01:19:28.300
George Mulhearn: Yeah. Yeah.

862
01:19:28.780 --> 01:19:36.679
Bogdan Mircea: yeah, I guess. But it's not about sorry jurors. That's not about the that's about the

863
01:19:37.240 --> 01:19:43.429
Bogdan Mircea: The connection should still be serializable in the serializable without any issue.

864
01:19:44.080 --> 01:19:46.369
Patrik Stas: So you

865
01:19:47.130 --> 01:19:48.380
Bogdan Mircea: right? Yeah.

866
01:19:48.550 --> 01:19:51.250
Patrik Stas: And I forget about this.

867
01:19:52.970 --> 01:19:58.010
Patrik Stas: Okay. So we are back where we started. But it was a good exercise.

868
01:19:58.720 --> 01:20:03.259
George Mulhearn: Yeah. So so going off what you're saying.

869
01:20:03.310 --> 01:20:04.340
George Mulhearn: I guess

870
01:20:04.590 --> 01:20:08.380
George Mulhearn: Aries Vcx is not a 100% ready to make

871
01:20:08.630 --> 01:20:10.150
George Mulhearn: a promise that

872
01:20:10.200 --> 01:20:12.280
George Mulhearn: a serialized connection. Now

873
01:20:12.430 --> 01:20:14.639
George Mulhearn: we'll be able to deserialize. And

874
01:20:14.870 --> 01:20:17.429
George Mulhearn: 2 years time in in the long term future.

875
01:20:18.540 --> 01:20:25.329
Bogdan Mircea: Yeah, I mean not. Not that we can make that promise. What we can from is that

876
01:20:26.130 --> 01:20:43.120
Bogdan Mircea: that if you serialize a connection today and you serialize it again in 2 years, that the 2 strings will be the same, provided that the connection is exactly the same. I think that's the promise we can, whether you can. This your life from both the old and the new string we can definitely accommodate that.

877
01:20:44.680 --> 01:20:46.510
George Mulhearn: Yes, but you you'd need

878
01:20:46.750 --> 01:20:48.940
George Mulhearn: potentially like some migration

879
01:20:49.030 --> 01:20:51.209
George Mulhearn: when you deserialize it, I guess.

880
01:20:51.780 --> 01:21:03.679
Bogdan Mircea: Yeah, you can. You can do an attempt to be serialize, and not to the new format, which should be the default, I guess. And then, if that fails, you can just right to this realized to the old format, and then transpose that to the

881
01:21:03.730 --> 01:21:05.999
Bogdan Mircea: current connection State machine.

882
01:21:06.200 --> 01:21:08.150
Bogdan Mircea: It's it wouldn't be too difficult.

883
01:21:08.750 --> 01:21:13.510
Bogdan Mircea: Then it would be completely transparent to users. They wouldn't have to do any sort of shenanigans, too.

884
01:21:13.860 --> 01:21:15.910
Bogdan Mircea: to to continue using that.

885
01:21:16.790 --> 01:21:18.599
George Mulhearn: Yes, yeah, I see. I see.

886
01:21:20.250 --> 01:21:28.450
Patrik Stas: Okay. So what about what about from and 2 parts bog done. I, as I understood you are.

887
01:21:28.610 --> 01:21:30.280
Patrik Stas: Yeah, I'm. On board.

888
01:21:30.560 --> 01:21:31.679
Bogdan Mircea: I'm on board.

889
01:21:31.710 --> 01:21:34.380
Patrik Stas: As I said, I think that people can

890
01:21:34.480 --> 01:21:38.470
Bogdan Mircea: like, regardless of what we're going to do, they They could Still.

891
01:21:38.830 --> 01:21:44.099
Bogdan Mircea: I know metal with that. So we might as well make it a bit more consistent.

892
01:21:45.140 --> 01:21:51.580
George Mulhearn: Yeah, I think I agree with hiding it behind a feature flag at least might be a good idea.

893
01:21:51.760 --> 01:21:55.420
George Mulhearn: because then they really the opt in and say they know what they're doing

894
01:21:55.940 --> 01:21:58.610
Bogdan Mircea: exactly. Yeah, I think I think it should be

895
01:21:58.680 --> 01:22:03.610
sort of of an advanced feature for people that really need it and really know what they're doing.

896
01:22:04.430 --> 01:22:09.610
Bogdan Mircea: and especially like if you take the I know the scenario of migrating from a different

897
01:22:09.760 --> 01:22:12.799
Bogdan Mircea: as agent implementation.

898
01:22:12.860 --> 01:22:14.939
Bogdan Mircea: You're probably gonna do that. You know.

899
01:22:15.140 --> 01:22:18.990
Bogdan Mircea: It's going to be a one time thing, right? So you could convert your

900
01:22:19.040 --> 01:22:23.820
your connections, maybe in a separate program. Store them back and then

901
01:22:23.880 --> 01:22:28.270
Bogdan Mircea: fire up the Paris Vcx agent or the Us. Vcx. Based agent.

902
01:22:28.450 --> 01:22:32.549
Bogdan Mircea: and just use it without doing anything in terms of that.

903
01:22:35.340 --> 01:22:36.040
George Mulhearn: Yeah.

904
01:22:37.420 --> 01:22:45.710
Bogdan Mircea: cool, so that you wouldn't even need the the feature flag in your in your main agents. That's what I mean. You could just do it separately as a one time thing.

905
01:22:45.950 --> 01:22:47.679
George Mulhearn: Yes, yes, yes, Gotcha.

906
01:22:49.510 --> 01:22:50.920
Patrik Stas: cool.

907
01:22:50.940 --> 01:22:55.749
George Mulhearn: and in terms of what this means for how it would be implemented.

908
01:22:56.110 --> 01:22:57.400
George Mulhearn: I found that

909
01:22:57.610 --> 01:23:04.919
George Mulhearn: all you really need is the the From parts method. To get this to work

910
01:23:05.000 --> 01:23:07.659
George Mulhearn: because you can reconstruct that.

911
01:23:08.040 --> 01:23:11.710
George Mulhearn: You know the requested State struct and all those structs

912
01:23:11.940 --> 01:23:17.480
Bogdan Mircea: right, and you need the into ports method so that you can deconstruct it as well.

913
01:23:17.910 --> 01:23:26.699
George Mulhearn: right. But but you can do that already with the the methods that are provided on that connection, like you know, dot there. Did, Doc

914
01:23:27.470 --> 01:23:29.820
George Mulhearn: all those methods?

915
01:23:30.550 --> 01:23:34.790
Bogdan Mircea: Yeah, but I don't think you can. I don't think you you have the state available.

916
01:23:36.290 --> 01:23:37.959
Bogdan Mircea: and I have to look into it a bit.

917
01:23:39.540 --> 01:23:41.999
George Mulhearn: I see what you mean. Yeah.

918
01:23:42.870 --> 01:23:51.729
Bogdan Mircea: yeah. So you you cannot get the the actual state. Let's say the what's called the fat state that actually has the data in it. You can get a thin state of from a generic connection

919
01:23:51.840 --> 01:23:55.609
Bogdan Mircea: for runtime matching. But you don't get the data inside the state.

920
01:23:57.210 --> 01:24:02.510
Bogdan Mircea: So yeah, we can just implement an an additional method from parts and into parts. I mean, that's it.

921
01:24:05.000 --> 01:24:10.090
George Mulhearn: Yeah, Cool: yeah, the the from parts method you have at the moment, which is

922
01:24:10.200 --> 01:24:11.969
George Mulhearn: pub, Crate.

923
01:24:12.420 --> 01:24:14.699
Bogdan Mircea: Yeah, I I'll just make it public.

924
01:24:14.790 --> 01:24:18.429
Bogdan Mircea: Yeah, yeah, if not, at least from my used case. That's that's all I needed

925
01:24:18.760 --> 01:24:20.090
George Mulhearn: to get things to work.

926
01:24:23.110 --> 01:24:26.990
George Mulhearn: But maybe there should be other 2 parts methods, if

927
01:24:27.230 --> 01:24:34.790
Bogdan Mircea: yeah, essentially, i'm thinking again about the state. So the States cannot be constructed, I believe.

928
01:24:37.440 --> 01:24:38.810
Bogdan Mircea: Oh, you can. Actually.

929
01:24:39.090 --> 01:24:40.620
Bogdan Mircea: you can construct the State.

930
01:24:41.010 --> 01:24:44.070
Bogdan Mircea: Yeah, yeah, they're all public. The States.

931
01:24:44.650 --> 01:24:48.429
Bogdan Mircea: Yeah, okay. So you can. You can construct the State, they will have the new method

932
01:24:50.150 --> 01:24:56.889
Bogdan Mircea: so given that you can construct your state, pass it to from parts of method of a connection. And then

933
01:24:56.930 --> 01:24:57.799
Bogdan Mircea: there you go.

934
01:24:58.460 --> 01:25:05.119
George Mulhearn: Yeah, yeah, and all the constructors for your for your State objects. They sort of take in the the main

935
01:25:05.200 --> 01:25:12.790
George Mulhearn: primitive, like the invitation message and the threat Id and they did duck. It's very like

936
01:25:13.540 --> 01:25:14.230
Bogdan Mircea: right.

937
01:25:15.730 --> 01:25:17.059
George Mulhearn: which is, which is great

938
01:25:18.260 --> 01:25:18.809
Bogdan Mircea: Cool?

939
01:25:19.590 --> 01:25:21.779
Bogdan Mircea: Yes, so I guess this settles it. Then.

940
01:25:25.760 --> 01:25:29.110
Patrik Stas: Yeah, I think I think we good. So

941
01:25:32.400 --> 01:25:40.759
Patrik Stas: yeah, it was a. It was a good discussion. It was a long call. I think it was. It was worth it. It was a good one.

942
01:25:43.060 --> 01:25:47.649
Patrik Stas: Yeah. And we we covered everything all this on the agenda. So

943
01:25:47.800 --> 01:25:49.740
Patrik Stas: thank you guys again for

944
01:25:50.120 --> 01:25:55.699
Patrik Stas: helping on on here, and even staying overboard. Oh, oh.

945
01:25:55.720 --> 01:25:58.280
and it's almost 25min later.

946
01:25:58.960 --> 01:26:04.229
Patrik Stas: So yeah, thank you. So much. And enjoy your weekend, which is coming soon.

947
01:26:04.500 --> 01:26:06.240
Patrik Stas: and i'll see you next week.

948
01:26:07.380 --> 01:26:10.969
George Mulhearn: Cool. Thank you. You, too. Yeah, thanks for the

949
01:26:11.800 --> 01:26:12.780
Bogdan Mircea: to my place.

950
01:26:13.010 --> 01:26:14.480
Bogdan Mircea: Have a good one, Bye bye.

951
01:26:14.780 --> 01:26:15.710
George Mulhearn: Do zo.

