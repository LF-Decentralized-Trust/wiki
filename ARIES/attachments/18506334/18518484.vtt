WEBVTT

1
00:03:04.650 --> 00:03:05.790
Bogdan Mircea: Hey, Patrick.

2
00:03:06.910 --> 00:03:08.080
Patrik Stas: good morning!

3
00:03:16.120 --> 00:03:17.519
Patrik Stas: Is the

4
00:03:19.840 --> 00:03:22.080
Patrik Stas: Hi innocence at your pilot?

5
00:03:26.920 --> 00:03:28.559
Patrik Stas: I'm I'm not sure

6
00:03:29.960 --> 00:03:32.840
Patrik Stas: if it's a malt. or

7
00:03:48.810 --> 00:03:50.540
Patrik Stas: well, anyway.

8
00:03:50.870 --> 00:03:52.980
Patrik Stas: oh, we have 9

9
00:03:55.630 --> 00:03:56.779
Patrik Stas: and

10
00:03:57.480 --> 00:03:58.240
Naian: Hi.

11
00:03:58.350 --> 00:03:59.749
Patrik Stas: good to have yet.

12
00:04:04.260 --> 00:04:05.320
Naian: And

13
00:04:06.290 --> 00:04:11.159
Patrik Stas: we we get more people join us.

14
00:04:11.560 --> 00:04:13.869
Patrik Stas: gonna start in the short moments.

15
00:04:18.500 --> 00:04:21.110
Patrik Stas: I it is a I. Okay.

16
00:04:53.460 --> 00:05:06.880
Patrik Stas: it's interesting. I remember, actually the I think the first time the innocence autopilot icon connected. I was actually a person. And I guess it was innocent. It was innocent grades.

17
00:05:07.020 --> 00:05:10.049
Bogdan Mircea: It actually says that it's his book.

18
00:05:11.600 --> 00:05:21.579
Patrik Stas: Yeah, right? Like, I'm a I assistant helping innocent rates taking notes. okay. You see, it's like personal. But

19
00:05:21.790 --> 00:05:30.599
Patrik Stas: but I don't think it's actually for personal I don't know otherwise. Oh, who knows? Maybe I'm just

20
00:05:31.250 --> 00:05:38.399
Patrik Stas: to an untrustful to this. AI. But maybe it's actual, genuine person just saving their time.

21
00:05:38.420 --> 00:05:49.179
Patrik Stas: anyway. if you hear us innocence, other pilot, it will be happy. You sometimes. Don't join us in person. If if these words get you through the Transcript.

22
00:05:49.420 --> 00:05:52.950
Patrik Stas: anyway, let's get started, so I'll share my screen

23
00:05:57.550 --> 00:06:00.470
Patrik Stas: just short moments.

24
00:06:02.770 --> 00:06:06.990
Patrik Stas: Holds up all the unimportant windows I have.

25
00:06:08.560 --> 00:06:10.599
Patrik Stas: I think that's good.

26
00:06:24.540 --> 00:06:35.969
Patrik Stas: Alright, so we'll come to July 22,023. Our community call. And that trust policy of hyper Ledger is in effect.

27
00:06:36.940 --> 00:06:38.400
Patrik Stas: and

28
00:06:39.750 --> 00:06:46.530
Patrik Stas:  and yeah, let's get started.

29
00:06:46.660 --> 00:06:54.420
Patrik Stas: So I don't think there's any introductions today. it's not a new people.

30
00:06:57.660 --> 00:07:10.509
Patrik Stas: I'll be guttery kind of Well, I I I did this in, inspired by other other meetings, I that under this. recently, I I added these kind of points to to make sure that

31
00:07:10.680 --> 00:07:13.640
Patrik Stas: if you if you guys have anything

32
00:07:14.050 --> 00:07:21.880
Patrik Stas: on mine, you would like to add to agenda. You can like this pointed out now so we can

33
00:07:22.270 --> 00:07:23.400
Patrik Stas: adjusted

34
00:07:24.580 --> 00:07:35.889
Bogdan Mircea: I added. Some stuff just a couple of minutes ago to the end meeting discussion, but just to just keep in mind. But they they they're already there. So nothing new to that.

35
00:07:41.440 --> 00:07:45.609
Patrik Stas: Alright so I guess that that would be it.

36
00:07:47.940 --> 00:08:00.750
Patrik Stas: you know. Nevertheless, if you if if someone will have an idea and a thought you would like to put out there feel free, and the time during the meeting, nevertheless.

37
00:08:00.770 --> 00:08:11.850
Patrik Stas: yesterday we had a presentation on Aries for group call. So the recording is available there. You would like to see we did the presentation of

38
00:08:12.220 --> 00:08:20.289
Patrik Stas: I. there will be upload that diagram we created. And I also put it here

39
00:08:20.320 --> 00:08:28.889
Patrik Stas: as kind of status overview of what we are, what we did, what we are doing, what we are planning to do.

40
00:08:31.300 --> 00:08:41.480
Patrik Stas: next up I kept this item here in case that it kind of option optional update. So

41
00:08:41.590 --> 00:08:49.480
Patrik Stas: I see that we have only 9 here. So if you would like to give an update you know you you can.

42
00:08:49.630 --> 00:08:56.650
Patrik Stas:  Would you like to say say a few words about

43
00:08:56.880 --> 00:09:00.490
Patrik Stas: you know what? What's your latest progress is?

44
00:09:03.660 --> 00:09:05.760
Naian: Hello, yeah.

45
00:09:05.880 --> 00:09:11.709
Naian: So yesterday, in the slack chat I was recommended to look into

46
00:09:11.870 --> 00:09:15.570
Naian: feature flags, and to basically

47
00:09:15.690 --> 00:09:21.619
change the implementation of the database back in from in any database

48
00:09:21.650 --> 00:09:26.950
Naian: to selecting one particular database at compile time rather than

49
00:09:27.100 --> 00:09:29.720
selecting the database at Runtime.

50
00:09:29.900 --> 00:09:30.840
Naian: So

51
00:09:31.000 --> 00:09:41.510
I looked into feature flags. And I think I've implemented that in on the server. Now, the sender link in chat.

52
00:09:41.780 --> 00:09:45.439
Naian: So basically, what I do is I have some

53
00:09:45.970 --> 00:09:50.480
Naian: teacher flag, I mean future flag based. code.

54
00:09:50.840 --> 00:09:55.929
Naian: When you give a feature flag saying, Okay, we're going to activate my sequel.

55
00:09:56.000 --> 00:10:02.659
Naian: Then it's going to only load the code that's required to give a Mysql pool

56
00:10:02.940 --> 00:10:04.060
Naian: and so on.

57
00:10:04.150 --> 00:10:10.539
Naian: So for postdress. I'll do postless by default. I have activated my sequel.

58
00:10:10.550 --> 00:10:21.809
Naian: and if someone says they want posters, they can activate posters. If someone says they want any pool that is runtime selected database. Then they can do that also.

59
00:10:22.520 --> 00:10:25.500
Yeah. So that's where I'm right now.

60
00:10:25.940 --> 00:10:27.150
Naian: Since yesterday.

61
00:10:27.420 --> 00:10:28.330
Patrik Stas: right

62
00:10:29.330 --> 00:10:36.359
Patrik Stas: cool, cool, and we have lots of discussion about like the overall architecture and the protocols and stuff like that, right

63
00:10:36.640 --> 00:10:41.190
Patrik Stas: is is what? What's your kind of,

64
00:10:41.460 --> 00:10:45.029
Patrik Stas: you know, maybe feeling of

65
00:10:45.930 --> 00:11:01.429
Patrik Stas: like, do you feel like, you understand? Like the big picture like, do you have some like kind of shadow areas? Or you feel like you still need to kind of shed some more light on, but it's a little bit mysterious. What's your kind of, you know.

66
00:11:02.040 --> 00:11:09.470
Patrik Stas: feel or thought on the overall project scope and like the the work ahead and things like that

67
00:11:11.160 --> 00:11:40.659
Naian: right? I I think I'm getting a hang of it right now, like, especially on one side, working on the server. And then we had, like the discussion on Tuesday, you explained through the connection protocol and the whole flow of the mediator with the Rfcs. So I do have some understanding of it right now, of course. the interaction with Aries. We see export.

68
00:11:40.820 --> 00:11:44.849
That for me right now is a blur.

69
00:11:44.890 --> 00:11:48.169
Naian: But I guess over time when I actually look into

70
00:11:48.420 --> 00:11:58.550
Naian: the code, then it'll make more sense. So right now the Aries we see, exports, the methods that I'll be calling there. That's foreign to me.

71
00:11:58.710 --> 00:12:00.670
Naian: Yes.

72
00:12:00.980 --> 00:12:05.450
Naian: and I dive into the code. Maybe it'll make more sense like we have to

73
00:12:05.490 --> 00:12:10.840
Naian: back and forth with you all to understand how this works and stuff

74
00:12:10.920 --> 00:12:12.450
Naian: I did have a session

75
00:12:12.710 --> 00:12:13.750
Naian: of.

76
00:12:15.320 --> 00:12:17.460
So last Friday

77
00:12:18.960 --> 00:12:20.949
Naian: I had a session

78
00:12:22.960 --> 00:12:31.729
with the Viruslav about the message. Create, I think. Yes.

79
00:12:36.170 --> 00:12:38.409
yes, yes, so.

80
00:12:38.470 --> 00:12:43.710
Naian: So we have the session about the message trade, and we discussed in lens

81
00:12:44.020 --> 00:12:51.389
a mode. It and yes, some parts are quite complex. But yeah, I mean.

82
00:12:51.650 --> 00:12:54.080
Naian: I'm getting a feeling for it now.

83
00:12:54.400 --> 00:13:02.119
Naian: with time, I guess, looking into the concepts more and reading about it. I think it'll make more sense.

84
00:13:02.420 --> 00:13:03.190
Naian: Yeah.

85
00:13:03.520 --> 00:13:12.210
Patrik Stas: hmm, sounds good. That's that's great. Actually, now, as as you mentioned, like A, it's kind of a blur for you, as

86
00:13:12.260 --> 00:13:27.090
Patrik Stas: brings me the reminds me of the idea from George Mohear, about creating, like Ellie's T or C, like Demo. And we just got freshly merged. Pr.

87
00:13:27.150 --> 00:13:36.430
Patrik Stas: about like a kind of simple message related essentially like extremely simplistic. Maybe if we can even call it that way, it kind of serves

88
00:13:36.710 --> 00:13:48.030
Patrik Stas: like ultimately councillors per post. But it's like a few lines of code, essentially but this will make it much simpler to create some sort of what kind of a

89
00:13:48.120 --> 00:14:01.869
Patrik Stas: showcase of how a aresy 6 can be consume. So I think we can find now, like, address this and actually create some like simply a stable demo, and that I guess the earlier we do it.

90
00:14:01.970 --> 00:14:13.150
Patrik Stas: Perhaps it, it can actually be a helpful for you as well. you know, I, I of starting the integration of as Dcx with the naviator code

91
00:14:13.820 --> 00:14:19.610
Naian:  all right. So look in.

92
00:14:19.950 --> 00:14:20.730
Naian: Yeah.

93
00:14:20.860 --> 00:14:29.849
Patrik Stas: thank you. Thank you for update. We don't have socknowled so, and me neither. George, so I'll I'll

94
00:14:29.870 --> 00:14:42.870
Patrik Stas: I'll skip over this one. I can. I'm not really in position right now to cover it, but I just know that there is a Pr. For a while, and it's been progressing somewhat

95
00:14:43.130 --> 00:14:52.110
Patrik Stas: there in some comments, so we'll see how this goes.  all right. So

96
00:14:52.120 --> 00:15:01.870
Patrik Stas: to back to the more mundane part of the a meeting. so we had a really 0 57. recently.

97
00:15:01.910 --> 00:15:09.509
Patrik Stas: yesterday. you had to have to adjust this change like this autumn generated. But

98
00:15:09.740 --> 00:15:19.660
Patrik Stas: it can be a pretty fight and structured. So we'll do that. There's lots of stuff in went into that because we're gonna have release for a

99
00:15:20.080 --> 00:15:23.789
Patrik Stas: It was at least a month, maybe more.

100
00:15:23.890 --> 00:15:32.439
Patrik Stas: So I'll I'll kind of make these nice during. It'll be easier to understand all the stuff fund in here.

101
00:15:33.800 --> 00:15:39.909
Patrik Stas: Then we had the message really from George as mentioned before.

102
00:15:40.040 --> 00:15:47.989
Patrik Stas: and lastly, that was a number of micro or like many fixes

103
00:15:48.030 --> 00:15:54.760
Patrik Stas: some refactoring some

104
00:15:54.860 --> 00:16:01.029
Patrik Stas: in terms of tells their entails file variable names

105
00:16:01.260 --> 00:16:08.600
Patrik Stas: Then the removing unused Constance, and lastly, some Ci fix

106
00:16:09.670 --> 00:16:13.560
Patrik Stas:  Then in progress. We have a

107
00:16:13.920 --> 00:16:21.829
Patrik Stas: kind of well, rather not not really in progress right now. We have post credits to an on credit migration.

108
00:16:21.990 --> 00:16:34.220
Patrik Stas: We have. Pr for it. but it's more of a draft. Just a reference point for the future. and we pause. This we we we need to get good

109
00:16:34.480 --> 00:16:37.169
Patrik Stas: clear up some things about

110
00:16:38.160 --> 00:16:46.259
Patrik Stas: intentions of an on threads and the and a plan just to make sure that our plan and our approach is is right.

111
00:16:46.320 --> 00:16:52.480
Patrik Stas: I know, George. Bogan, do you want to drop any any more words on on this topic.

112
00:16:54.340 --> 00:17:00.859
Bogdan Mircea: Yeah, I don't know. I guess we've been discussing about this but length, but overall

113
00:17:00.930 --> 00:17:03.530
Bogdan Mircea: with the outline, it's pretty much about

114
00:17:03.560 --> 00:17:09.839
Bogdan Mircea: kind of getting a better understanding of what the plans are regarding all the underlying libraries, and

115
00:17:10.760 --> 00:17:13.909
Bogdan Mircea: how to align, or even maybe shape them

116
00:17:14.020 --> 00:17:17.790
Bogdan Mircea: ourselves, or help with that

117
00:17:17.810 --> 00:17:22.539
Bogdan Mircea: and also our line. I'll align our goals and approach

118
00:17:23.030 --> 00:17:33.410
Bogdan Mircea: to to better fit into that, because we haven't really done that so far. And this kind of biting. It is biting us in the back, so  the the sooner it better.

119
00:17:33.730 --> 00:17:35.690
Bogdan Mircea: Kinda kind of thing.

120
00:17:35.990 --> 00:17:47.449
Patrik Stas: Yeah. all right. next up the Dixon's protocol is, Well, it's simply progress still. so lots of back and forth.

121
00:17:47.530 --> 00:17:54.379
Patrik Stas: I think last we got mirror it was he he said, that I got some

122
00:17:54.620 --> 00:18:11.159
Patrik Stas: that's passing, but he's is not satisfied with the implementation. So he's kind of reiterating and trying to find that but better ways before he kind of pushes it out there into ether publicly. So is this still in progress?

123
00:18:11.230 --> 00:18:29.350
Patrik Stas: next up? I personally have a and other small Pr to clean up some discrepancies about tales. Do you like still file variables in the issues code that might be actually breaking change like a breaking change, but without the lunch impact, I believe.

124
00:18:29.700 --> 00:18:33.210
Patrik Stas: and lastly,

125
00:18:33.400 --> 00:18:44.410
Patrik Stas: bogged down started Vdr tools. Critics world migration like a a I think the Api to the Nodejs

126
00:18:44.500 --> 00:18:55.690
Patrik Stas:  is, is that is that we have a pr for it? But those some comments is it? Is it in progress, or, are we?

127
00:18:55.920 --> 00:19:02.569
Bogdan Mircea: Since yesterday? It's just the those tests that have intermittent fails.

128
00:19:02.760 --> 00:19:08.460
Bogdan Mircea: the the building was they're not related to the test or anything like that. So I added the test for

129
00:19:08.540 --> 00:19:10.319
the the rapper

130
00:19:11.370 --> 00:19:21.199
Bogdan Mircea: or the function exposed through the wrapper, and it all seems to work fine so it can mean it can be reviewed and even marched, should be should be in order.

131
00:19:21.460 --> 00:19:22.230
Okay, cool.

132
00:19:22.450 --> 00:19:36.019
Patrik Stas: All right. Upcoming work. We have the Cli demo. We want to do the seal. I don't know. I think if we do it as soon as possible, it can kind of accelerate 9 for sure with the the mediator. Or is this integration

133
00:19:36.260 --> 00:19:43.900
Patrik Stas: the state pattern? I mean, I think I should remove that. It's like all topic we all know this is happening. We are doing it and did exchange.

134
00:19:44.080 --> 00:20:08.769
Patrik Stas: we are gonna do it in other protocols. But technically, it's still upcoming. Okay? And it inspection updates. that's actually in progress on when I move this item, because Meadow is busy with that, he is a first step as a as a part of integrating and implementing the exchange it found it useful to

135
00:20:08.820 --> 00:20:31.979
Patrik Stas: basically start testing with testing that did the exchange implementation against occupy and other implementations right away. So, but the first step to even be able to do that or so to update A or G 6 version in the adh, so I believe this is done. And now it's on a stage of like adding

136
00:20:32.180 --> 00:20:42.220
Patrik Stas: the support for did exchange into the at H back channel kind of in a parallel with actually implementing the exchange.

137
00:20:43.040 --> 00:20:57.039
Patrik Stas: And yeah, then we have the coming to the end meeting discussions. And this items and from both down. So I I'll leave it to you to to moderate, or what you wanted to have say about these.

138
00:20:58.000 --> 00:21:12.350
Bogdan Mircea: Yeah. So Since that the the migrators for the exposing it through the Nodejs was done is they started working on the getting kind of getting the connection protocol up to speed with the

139
00:21:12.880 --> 00:21:26.360
Bogdan Mircea: let's say, the design choices that we've made regarding State machines. so the connection with protocol was pretty much the first and only so far to implement the type State pattern, and

140
00:21:26.620 --> 00:21:37.009
Bogdan Mircea: we further it rate on that to kind of change the States from sending a message to just generating the message and leaving it up to the user to do that.

141
00:21:37.190 --> 00:21:46.109
Bogdan Mircea: and I believe mirror is basically shaping the did exchange state machine protocol implementation to

142
00:21:46.410 --> 00:22:01.290
Bogdan Mircea: fit that design. There's George's Pr on, Holder. It's kind of being stayed for a while. But anyway, he started, and in that fashion as well. And yeah, I kind of wanted to get some hands on experience with this and kind of see the challenges and

143
00:22:01.400 --> 00:22:03.620
Bogdan Mircea: all that

144
00:22:04.420 --> 00:22:10.059
Bogdan Mircea: and the main thing that I guess represents a

145
00:22:11.400 --> 00:22:17.859
Bogdan Mircea: I don't know where it poses. Some problems is what exactly should happen

146
00:22:17.960 --> 00:22:20.429
Bogdan Mircea: from from consumers.

147
00:22:20.560 --> 00:22:28.010
Bogdan Mircea: Customer of the library point of view with the outcome of the State machine, or how are they supposed to even process it

148
00:22:28.030 --> 00:22:37.519
Bogdan Mircea: so ultimately, regardless of the protocol and State machine? There are pretty much 3 things that can happen. You

149
00:22:38.280 --> 00:22:48.060
Bogdan Mircea: like, you get a message, you locate your state machine and you want to process it. So once that processing starts. There are basically 3 possible outcomes. You either

150
00:22:48.100 --> 00:22:53.990
Bogdan Mircea: everything, either. Everything works well and you get your new. You get the state machine to the new state.

151
00:22:54.610 --> 00:23:01.360
Bogdan Mircea: or some things fail, and but that doesn't necessarily

152
00:23:01.910 --> 00:23:10.629
Bogdan Mircea: terminate the the protocol. It's just. I know it could be requireable So you still have your state machine in your old state, and that's fine.

153
00:23:11.120 --> 00:23:20.350
Bogdan Mircea: There are for directions that you can do based on that. But maybe send the problem report or not. I don't know that's debatable, and it's not necessarily the point here.

154
00:23:20.710 --> 00:23:27.420
Bogdan Mircea: but the and the other. The third outcome is basically that I know some sort of fatal error occurred, and the

155
00:23:27.690 --> 00:23:35.660
Bogdan Mircea: instance should be terminated completely and is not retrial. So it's basically success, the tribal

156
00:23:35.930 --> 00:23:39.850
Bogdan Mircea: or like error, but with tribal and error. But fatal

157
00:23:40.510 --> 00:23:47.000
Bogdan Mircea:  And I've been thinking about like how to kind of

158
00:23:47.800 --> 00:23:56.960
Bogdan Mircea: deal with this, because this is going to be sort of a universal thing. Now, obviously, for instance, the the connection protocol doesn't even have like a failure state. It doesn't terminate.

159
00:23:57.010 --> 00:24:01.019
Bogdan Mircea: There is no fatal error that can technically occur.

160
00:24:01.210 --> 00:24:03.180
Bogdan Mircea: but

161
00:24:03.540 --> 00:24:08.850
Bogdan Mircea: I believe the this. This actually became a topic of discussion

162
00:24:09.150 --> 00:24:20.709
Bogdan Mircea: when George started working on the holder implementation, which apparently does have some like failed states where the the

163
00:24:21.110 --> 00:24:26.819
Bogdan Mircea: instance of the protocol is not supposed to be to be retried. So it should be terminated.

164
00:24:27.280 --> 00:24:35.239
Bogdan Mircea:  and nevertheless, it's it's a matter of how could we perhaps approach that

165
00:24:35.460 --> 00:24:43.990
Bogdan Mircea: and a more organized and uniform fashion, since. having all these different outcomes like, if you take

166
00:24:44.590 --> 00:24:53.239
Bogdan Mircea: a singular transition and consideration. The transition might be successful all the time, or it might be successful and

167
00:24:53.350 --> 00:25:08.000
Bogdan Mircea: successful or retrial, or it might be successful or fatal, or it might be all 3, and having differences in these results that were these return types from the transition

168
00:25:08.490 --> 00:25:39.869
Bogdan Mircea:  can make it especially confusing for consumers of the library right? Because in the end, if you look at the ecosystem and the other implementations, and that's maybe something that I'll go that I want to talk about more in the regarding the second point, but they're more like batteries included, or there are more abstractions going on, so that consumers are not that concerned with the actual implementations, with the functionalities of the protocols and whatnot.

169
00:25:40.490 --> 00:25:50.969
Bogdan Mircea: because, frankly, they don't even have to be like people generally just want an agent to work and just do its magic under the hood. Now, obviously having flexibility of

170
00:25:51.200 --> 00:25:56.789
Bogdan Mircea: changing stuff around. To better suit your needs in your use cases is is a great thing.

171
00:25:56.960 --> 00:26:05.520
Bogdan Mircea: but I'm certain that the majority of people just want a working thing.  and

172
00:26:06.070 --> 00:26:14.510
Bogdan Mircea: basically, as a consequence of that, when you have the all these transitions from all the protocols and all the state machines, and they

173
00:26:14.630 --> 00:26:21.180
Bogdan Mircea: each kind of return a different thing that you have to handle differently because they're different.

174
00:26:21.760 --> 00:26:29.230
Bogdan Mircea:  it kind of makes things convoluted and complex and hard to keep track of and hard to understand

175
00:26:29.460 --> 00:26:36.940
Bogdan Mircea: again, maybe not for us as developers. But we have to kind of consider the people that would be using this as well. So

176
00:26:37.750 --> 00:26:46.730
Bogdan Mircea:  I've been mainly thinking about the uniform approach of  kind of a a uniform

177
00:26:46.740 --> 00:26:50.409
Bogdan Mircea: yeah, uniform result, if you will, of the State machine

178
00:26:50.700 --> 00:27:08.810
Bogdan Mircea: of a State machine transition. So regardless of the protocol and state machine and the state. It would basically return an enum with these variants. And there's also the the idea of what what should you do as a consumer. If you get an error in a transition, right?

179
00:27:09.130 --> 00:27:14.830
Bogdan Mircea: I want to think about a second. I want to think about that a second, because

180
00:27:15.430 --> 00:27:21.399
Bogdan Mircea: if you get an error in the state machine, especially given the type state pattern that we employ and

181
00:27:21.550 --> 00:27:25.300
Bogdan Mircea: the fact that it's a consuming operation.

182
00:27:26.560 --> 00:27:40.520
Bogdan Mircea: you cannot just error out and propagate your E. C.

183
00:27:40.560 --> 00:27:56.290
Bogdan Mircea: Consider that if you get a successful transition you might want to update your state machine and your permanent storage or database for your cash or whatever. But you definitely need to do something based on that. So if you get a success, you need to do some stuff

184
00:27:56.380 --> 00:28:03.159
Bogdan Mircea: if you get a retrial or I know a retrial outcome. So you get an error. But the outcome is triable. Now.

185
00:28:03.370 --> 00:28:06.960
Bogdan Mircea: what we kind of want to do is return the old stay machine, as is

186
00:28:07.000 --> 00:28:10.850
Bogdan Mircea:  but that might also imply that

187
00:28:11.030 --> 00:28:16.990
Bogdan Mircea: I don't. If you have some in-memory cache where you took the state machine out of you might want to put it back.

188
00:28:17.490 --> 00:28:27.200
Bogdan Mircea: So again, you might want to do something based on that. Additionally, I know, if you have a a problem report that comes out of the state machine.

189
00:28:27.500 --> 00:28:29.120
Bogdan Mircea: You might want to send that

190
00:28:29.270 --> 00:28:39.119
Bogdan Mircea: So it's not just a matter of okay. I got an error. It's a result. I'm just going to use the question mark and throw this up the more technically down the stack

191
00:28:39.420 --> 00:28:59.249
Bogdan Mircea:  and then, if you if like. If the stay machine just terminates, you get a fatal er then again, you need to do some stuff. You might want to clean up the state machine instance from your permanent storage from your cache, because that's not supposed to exist anymore. There's not that much that you can do with it. You can definitely leave it there if you want, but

192
00:28:59.330 --> 00:29:02.440
Bogdan Mircea: I assume people will generally just want to get rid of it.

193
00:29:02.520 --> 00:29:05.560
Bogdan Mircea:  So

194
00:29:05.740 --> 00:29:09.799
Bogdan Mircea: nevertheless, there's stuff that you need to do in practically every case of this

195
00:29:10.060 --> 00:29:14.059
Bogdan Mircea:  and what that means is that

196
00:29:14.650 --> 00:29:16.050
Bogdan Mircea: even if we

197
00:29:16.280 --> 00:29:23.529
Bogdan Mircea: kind of consider just returning the result with some stuff. I'm not even sure that's like I I tend to believe that's not really

198
00:29:23.700 --> 00:29:24.980
Bogdan Mircea: the

199
00:29:26.000 --> 00:29:37.860
Bogdan Mircea:  That's not really the the way to go about this. What did you write down? Assumption to remove state machine or failure? What was that?

200
00:29:39.280 --> 00:29:52.149
Patrik Stas: yeah, i' my screen. it was just a personal note, just a minor remark, you know. yeah, yeah, can you please repeat your last sentence?

201
00:29:53.470 --> 00:30:06.239
Bogdan Mircea: Yeah. So if if the transition like, if you encounter a fatal error, you might want to do something with that, but a different thing than what you would do with a recoverable error. Let's say

202
00:30:06.520 --> 00:30:07.630
Bogdan Mircea: you know.

203
00:30:08.040 --> 00:30:23.790
Bogdan Mircea: what what do you do. What do you want to do with that? It's absolutely up to the consumer, like whether they wanna just remove the state machine completely from all their storages, or I don't know log some intricate stuff based on what happened I don't know.

204
00:30:24.270 --> 00:30:34.560
Bogdan Mircea: But you definitely want to do something, and the odds are that it's gonna be something different than what you would do from if you if you encountered the record of a recoverable error.

205
00:30:34.790 --> 00:30:38.969
Bogdan Mircea:  Hi! How are you? You. Do you think that's fair?

206
00:30:39.450 --> 00:30:44.210
Patrik Stas: Yeah, it it. I think it's fair, and it makes sense.

207
00:30:44.930 --> 00:31:02.610
Patrik Stas:  yeah, I I I guess. So this is pointing towards like the may be pointing towards the kind of custom enum right kind of there will be a solution or implementation for this kind of idea.

208
00:31:02.630 --> 00:31:15.319
Patrik Stas: right? I I guess that could work honestly. It's it's a speed. We don't have a mirror here as a he's a kind of a more more

209
00:31:15.750 --> 00:31:42.559
Bogdan Mircea: in the bushes, like in in the in an active Warsaw about this topic right now. So like more opinions than me. this is still like just a discuss at the discussion level. Then, yeah, it would be. I mean, we'll definitely go and get him. If his opinion on this it would be, it would have been nice, and he was here. But I don't think it's that big of a deal right now. it. It makes

210
00:31:42.970 --> 00:31:49.300
Patrik Stas: it it. It makes sense to me. It is on top of my head. I

211
00:31:49.890 --> 00:32:05.550
Patrik Stas: I can't really tell. What are those who tribal, and what are those faithful error so honestly. Do you have any like? I don't. I know, I'm sure if you open the holders you hold their pull request

212
00:32:05.580 --> 00:32:08.180
Bogdan Mircea: one that George was working on.

213
00:32:08.440 --> 00:32:13.149
Bogdan Mircea: there's been discussion there about these things.

214
00:32:14.400 --> 00:32:17.830
Bogdan Mircea:  let me see if

215
00:32:26.120 --> 00:32:36.370
Bogdan Mircea:  okay

216
00:32:40.310 --> 00:32:43.430
Patrik Stas: for this.

217
00:32:43.670 --> 00:32:52.969
Bogdan Mircea: yeah. So when when the after the offer is received, and I guess the  The request is sent.

218
00:32:53.640 --> 00:33:00.930
Bogdan Mircea: apparently per the old Api. The State machine transition into failed or request sent. Now.

219
00:33:01.710 --> 00:33:08.609
Patrik Stas: so so is it some comment I can find about this. Sorry. There's actually there are some diagrams that you need.

220
00:33:09.890 --> 00:33:11.860
Patrik Stas: Maybe

221
00:33:12.350 --> 00:33:25.509
Bogdan Mircea: that was on the top. Yeah. So I guess this would be an example of. you know. Fatal layer, I assume, because once you transition to the failed state, you're not supposed to do anything

222
00:33:25.880 --> 00:33:31.009
Bogdan Mircea: by with that state machine anymore. or at least that was my understanding.

223
00:33:33.810 --> 00:33:38.049
Oh, let's see, I'm a now I'm looking at this.

224
00:33:38.840 --> 00:33:42.880
Patrik Stas: I'm almost confused because

225
00:33:43.390 --> 00:33:48.759
Patrik Stas: this the diagram I did here. It looks like it's doing like, I O in the

226
00:33:48.840 --> 00:33:53.949
Bogdan Mircea: yeah, this regard that that's not important. It's not necessarily about that.

227
00:33:53.970 --> 00:34:04.220
Patrik Stas: This was before we we're discussing the aisle thing. It's a matter of yeah.

228
00:34:04.230 --> 00:34:06.990
Bogdan Mircea: like an example of a I don't

229
00:34:07.520 --> 00:34:10.489
Bogdan Mircea: final, but failed. State.

230
00:34:10.719 --> 00:34:19.510
Patrik Stas: like we know ahead of time. Even if we do this multiple times, we'll never succeed right? Because it some like

231
00:34:19.530 --> 00:34:33.989
Bogdan Mircea: maybe it's issue with the request itself, or something like that. So that would be like a fatal error, right? But then you could have stuff like, I don't know.

232
00:34:34.699 --> 00:34:36.980
Bogdan Mircea: Ledger communication there.

233
00:34:37.070 --> 00:34:44.029
Bogdan Mircea: where it's just a matter of networking a networking problem, and that can be by all means retrial. Right? So

234
00:34:44.880 --> 00:34:48.169
Bogdan Mircea: But if we do like.

235
00:34:48.260 --> 00:34:54.969
Patrik Stas: like, I assume that, like on the I/O like in the State machine would be. Hmm.

236
00:34:55.900 --> 00:34:58.980
Patrik Stas: can I assume that it will be?

237
00:34:59.190 --> 00:35:14.760
Patrik Stas: It's just an example. But yeah, but I think it's it's still important to like. I I I I understand. Like, what what could it be? Actually in practice? So like it. I think it wouldn't be. It wouldn't be sending like

238
00:35:15.430 --> 00:35:21.070
Patrik Stas: response, because we are not doing that. I think it also wouldn't be ledger communication.

239
00:35:21.220 --> 00:35:29.269
Patrik Stas: Technically, it could be wallets. That's like the kind of thing like if you want to make it. Really. I guess

240
00:35:29.490 --> 00:35:32.969
Bogdan Mircea: communication

241
00:35:33.260 --> 00:36:00.880
Patrik Stas: from the world can be I mean, that's the I I for me that does the type of I/O. We will still keep in state machines, and that can technically fail because it's I. Right? So that's the only actually case in my mind where, like retribal, or could technically be returned because you could not reach your wallet because it's my sequel database or something.

242
00:36:01.720 --> 00:36:14.289
Patrik Stas: But I don't think any other cases, because everything else seems to be deterministic like, you got state, you got some into data, it works, or it doesn't work. The only the non-deterministic part is the wallet.

243
00:36:14.300 --> 00:36:18.230
Patrik Stas: So that that could be like retrial error.

244
00:36:19.570 --> 00:36:24.309
Bogdan Mircea: Right? So that's that's again an example of that. So

245
00:36:24.910 --> 00:36:28.350
Bogdan Mircea:  yeah, it's basically

246
00:36:28.410 --> 00:36:29.920
Bogdan Mircea: like a matter of

247
00:36:30.680 --> 00:36:34.889
Bogdan Mircea: kind of having the uniform approach for these

248
00:36:35.570 --> 00:36:36.600
Bogdan Mircea: and

249
00:36:37.790 --> 00:36:40.030
Bogdan Mircea: like the the thing with that

250
00:36:40.050 --> 00:36:42.720
Bogdan Mircea:  is that

251
00:36:43.910 --> 00:36:45.050
Bogdan Mircea: it's

252
00:36:45.960 --> 00:36:54.510
Bogdan Mircea: I know it's it's a nice thing to do. I kind of drafted something. It's by all means in a very early draft state.

253
00:36:54.960 --> 00:36:59.980
Bogdan Mircea: But If I could share my screen, maybe.

254
00:37:00.880 --> 00:37:12.189
Patrik Stas: Oh, I I mean what comes to my mind. Sorry just just a random thought is like having the retrial Eric gives us like option to actually.

255
00:37:13.880 --> 00:37:18.440
Patrik Stas: yeah, gives us option to have I O in state machines

256
00:37:18.570 --> 00:37:33.560
Patrik Stas: like, if we actually find out in during the implementation of full the verifier, or I don't know whatever features actually protocols gonna be that like, hmm! It's gonna it'll it'll be like really a lot more convenient like for the users. If

257
00:37:33.660 --> 00:37:43.289
Patrik Stas: you know the ledger communication, some sort of did. Resolution was actually in the State mission based on the based on the message received.

258
00:37:43.360 --> 00:37:50.889
Bogdan Mircea: Then we technically, yeah, the I/O inside and return reach travel error if I fails.

259
00:37:54.240 --> 00:37:59.439
Bogdan Mircea: we what I I lost you for a second there. So

260
00:37:59.830 --> 00:38:08.000
Bogdan Mircea: you were saying that it would be convenient for consumers if we had ledger interaction within the state machine.

261
00:38:08.220 --> 00:38:11.699
Patrik Stas: Yeah. So I mean.

262
00:38:11.920 --> 00:38:23.890
Patrik Stas: yeah. Yeah. So I'm just saying that, like having the retribal error gives us kind of a beg door, like a a, an option

263
00:38:23.940 --> 00:38:34.730
Patrik Stas: to put an aisle into a state machine. If we deem it as a. Because if we don't have a tribal, then we.

264
00:38:36.680 --> 00:38:57.820
Patrik Stas: if we don't have retribal, and we have I? O, then any I/O error will become like fatal or other. If everything is retrial, then even fatal errors are retrial. And it's like really stupid bad for consumers. Right? So either way, you kind of get a kind of a bad solution. But with the 3

265
00:38:58.220 --> 00:39:06.160
Patrik Stas: 3 So we travel in London tribal, you can technically have I/O errors and no, I errors

266
00:39:06.220 --> 00:39:16.949
Bogdan Mircea: exactly. Yeah. And there's basically maybe another simpler example. like, based on the thread id, you're supposed to verify that. Okay, the message that you got is

267
00:39:16.980 --> 00:39:30.589
Bogdan Mircea: you know, on the threat idea of this protocol instance, and if it doesn't match, it's not necessarily the end of the world. There's nothing wrong with the state machine. You just got the wrong message, and that's their problem, not yours. You can maybe send problem, report or whatever. But

268
00:39:31.180 --> 00:39:32.850
Bogdan Mircea: it's not

269
00:39:33.110 --> 00:39:37.959
Bogdan Mircea: something that went wrong with the state machine.

270
00:39:38.090 --> 00:39:40.359
Bogdan Mircea: or I don't know

271
00:39:40.590 --> 00:39:44.620
Bogdan Mircea:  Nevertheless. So

272
00:39:45.430 --> 00:39:49.280
Bogdan Mircea: yeah, basically, we could have something like this.

273
00:39:49.630 --> 00:39:54.270
Bogdan Mircea: which, like I said, it has the okay version which has the new state.

274
00:39:54.530 --> 00:39:59.619
Bogdan Mircea: the fail variant that has the old state, and maybe a problem report or an error.

275
00:39:59.740 --> 00:40:05.519
Bogdan Mircea: Let's not pick on this. Maybe we could have 4 variants instead, one that has a problem report and one that has an error.

276
00:40:06.040 --> 00:40:20.840
Bogdan Mircea: and then the aborted or the fatal or whatever variant that basically has. Honestly, I'm not even sure if it has to have something. I'm I'm starting to doubt those failed States as well like, what are you even supposed to do with those?

277
00:40:21.030 --> 00:40:28.499
Bogdan Mircea: there's not really that much that you can do. But let's assume that we have some failed States and State machines. So that's what you would get returned here.

278
00:40:28.920 --> 00:40:36.229
Patrik Stas: I'll just drop a note here, you know, because I and that's it relates to the you know. Note in my

279
00:40:36.370 --> 00:40:39.850
Bogdan Mircea: sublime, you were asking about

280
00:40:40.230 --> 00:41:00.649
Patrik Stas: a road like that. It it seemed like you had the assumption that when the State Mission fails like, you will throw it away. But I think, General, that's not true, because you, on some sort of like book, you know, keeping track of what those happening in the even for mobile use cases you often want to have like kind of a list of events

281
00:41:00.690 --> 00:41:09.620
Patrik Stas: and have actual name for it and and you would want to see like, you know, you felt to share credential or some something went wrong.

282
00:41:10.240 --> 00:41:29.829
Patrik Stas: Things like that, and and on the back and slot likewise, like you know, as a as a is that you sure I want to know if I felt to issue 10 credentials. I want to keep on a trick of that. So just just just a note that I think those spells states my opinion, are important.

283
00:41:30.700 --> 00:41:32.719
Bogdan Mircea: I'm not saying they're not important. But

284
00:41:33.010 --> 00:41:37.130
Bogdan Mircea: the what I'm trying to get at is, are they important in the

285
00:41:37.260 --> 00:41:40.440
Bogdan Mircea: context of the State machine

286
00:41:41.370 --> 00:41:46.850
Bogdan Mircea: states? Or are they important? Just as some events that you keep track of.

287
00:41:47.350 --> 00:41:50.769
Bogdan Mircea: because they're not the same thing. They that doesn't necessarily mean that

288
00:41:50.910 --> 00:42:05.970
Bogdan Mircea:  having, like you, might as well just get some sort of an error here, right? And that's an error of fatal error. And you know exactly what we're wrong. But without needing to. I don't know. Update your state machine or delete it, or whatever you want to do like

289
00:42:06.260 --> 00:42:07.320
Bogdan Mircea: the

290
00:42:07.410 --> 00:42:13.760
Bogdan Mircea: the bookkeeping doesn't necessarily mean that you have to maintain an instance of that State machine and the failed state

291
00:42:14.100 --> 00:42:15.440
Bogdan Mircea: necessarily.

292
00:42:16.150 --> 00:42:27.359
Patrik Stas: it can be then confusing, because you will have a State machine left in like non failed state. I know some like whatever requests send.

293
00:42:27.370 --> 00:42:37.540
Bogdan Mircea: Yeah. Which is why I was saying you could basically delete that and just keep track of the like the event that the this whole protocol instance failed.

294
00:42:37.970 --> 00:42:40.650
Bogdan Mircea: but not necessarily as part of the state machine.

295
00:42:45.270 --> 00:42:54.689
Bogdan Mircea: Hmm, okay, let's let's maybe nevertheless, like, I, I also understand what you're saying, and it's not necessarily but like, even if you have like a failed state and maybe keep it.

296
00:42:54.760 --> 00:43:05.659
Bogdan Mircea: I don't know. Together with the other States of the State machine, and you have some other bookkeeping job that maybe archives, old records, or something like that.

297
00:43:05.840 --> 00:43:09.009
Bogdan Mircea: That also seems perfectly fine. Honestly.

298
00:43:09.370 --> 00:43:30.760
Bogdan Mircea: it's it's not like there would be an an issue with that, and maybe I know in some regards it might even be clear. I don't know.  So that's definitely a matter for debate. But the the bottom line that I was trying to get at is that you definitely want to have a distinction between these and these, and regardless of which variant you get, you want to do something with it

299
00:43:30.940 --> 00:43:39.760
Bogdan Mircea: erez agmoni. Right? So if you have a failed state here. That means you still have to update your failed state like your state machine instance, in maybe your database, 100

300
00:43:40.010 --> 00:43:49.279
Bogdan Mircea: or your cash, because the next time, otherwise, like you said, the State machine would remain, would remain in its old state like request sent, and then

301
00:43:49.550 --> 00:43:52.639
Bogdan Mircea: you're not supposed to have it like that right?

302
00:43:54.780 --> 00:44:00.050
Bogdan Mircea:  I don't. Does that make sense?

303
00:44:01.950 --> 00:44:06.510
Patrik Stas: Sorry you you you you're not supposed to have it have it like what?

304
00:44:07.340 --> 00:44:17.409
Bogdan Mircea: So I I I was basically trying to get at that. Whatever variant you would get. You know, one of these variant that you get out of the state machine.

305
00:44:17.540 --> 00:44:21.940
Bogdan Mircea: You have to do something with it. You don't just propagate it

306
00:44:22.070 --> 00:44:28.969
Bogdan Mircea: someplace, else, you know, or you don't just propagate the or something else. You first need to do something with this.

307
00:44:29.570 --> 00:44:32.119
Bogdan Mircea: whichever it is. So

308
00:44:32.230 --> 00:44:40.140
Bogdan Mircea: if it's a success, you update the state machine. If it's a fatal error. Again, you need to update the state machine. So you said it to be in a failed state.

309
00:44:40.560 --> 00:44:44.169
Bogdan Mircea: and if it's like retrial, then

310
00:44:44.240 --> 00:44:51.200
Bogdan Mircea: you might want to do something with the old State. Maybe send a problem report, maybe log there, maybe do whatever you want to do.

311
00:44:51.440 --> 00:44:52.190
Patrik Stas: Yeah.

312
00:44:52.960 --> 00:44:56.890
Bogdan Mircea: right? Yeah. So that's kind of the

313
00:44:56.990 --> 00:44:59.929
make me think about this?

314
00:45:00.770 --> 00:45:10.029
Bogdan Mircea: I'm actually thinking that there's like this problem report where I'm maybe thinking of flattening this and just having 4 variants in here.

315
00:45:10.260 --> 00:45:12.869
Bogdan Mircea: and the reason for that is

316
00:45:13.420 --> 00:45:21.460
Bogdan Mircea: like, I think it should be our responsibility to generate. I know standard problem reports for things that we are aware, happened.

317
00:45:21.770 --> 00:45:30.669
Bogdan Mircea:  but not necessarily, or all errors result in a problem report. So

318
00:45:31.190 --> 00:45:39.389
Bogdan Mircea: that's why I think it might be helpful to have a distinction like sometimes you will return the old State and a problem report that the consumer can decide to send or not.

319
00:45:39.880 --> 00:45:57.170
Bogdan Mircea: or and in other cases you return the old state machine. So it's still a retrial error. But the error is not really meant to be a problem before like, if if the communication with the wallet fails. That's not a reason to send the problem report to the other part. It doesn't have anything to do with it.

320
00:45:57.680 --> 00:45:59.370
Bogdan Mircea: Right?

321
00:46:00.530 --> 00:46:08.199
Bogdan Mircea: yeah. So so that would be that. So you can consider maybe 4 variants here. just for the sake of flattening this

322
00:46:09.080 --> 00:46:19.579
Bogdan Mircea: I'm wondering if a if you ever you know, with the failed state which I consider that's supposed to represent the kind of retribal error. Right?

323
00:46:19.990 --> 00:46:24.350
Bogdan Mircea: Yeah. If you would actually ever send a problem report.

324
00:46:24.450 --> 00:46:31.729
Patrik Stas: You know, when you get to retrial or kind of error, because dudes are tribal.

325
00:46:32.230 --> 00:46:38.789
Patrik Stas: That means that some issue must have happened. You know, some issue must have happened like

326
00:46:40.050 --> 00:47:03.160
Patrik Stas: on your end, like typically with the I as I as I meant I I feel like we could even I. I'm not sure it might might be not with the I/O if something happens with the I/O, that's not the other parties. Problem. Yeah. Yeah. But I feel like the real problem is will be 19. I don't know 100, or, if not 199 I/O errors. It just can't think of anything else in aisle

327
00:47:03.340 --> 00:47:05.440
Patrik Stas: for retribal kind of ever

328
00:47:05.500 --> 00:47:08.039
Bogdan Mircea: like I said, the thread id that doesn't match.

329
00:47:08.250 --> 00:47:11.420
Patrik Stas: Hmm! But if it doesn't match, then

330
00:47:12.650 --> 00:47:15.890
Bogdan Mircea: they

331
00:47:16.640 --> 00:47:19.349
Patrik Stas:  or how would

332
00:47:19.930 --> 00:47:35.979
Patrik Stas: like it can be also your problem. You actually don't know. Maybe you just like did a bad job with like matching the correct seed machine. And now you're sending a problem record to, you know, maybe some someone else or like you. You you did that

333
00:47:36.430 --> 00:48:03.730
Patrik Stas: just you you you you've wrote the buggy code on top of this, and you'll match the wrong State mission based on a message you received. I would try to process the the message with the statement, and you incorrectly found in your database, let's say, and now it throws like, Oh, no matching thread Id, and you send a problem report. But there'll be like, actually, you know, actually, it's just what ended up being kind of confusing, because

334
00:48:05.090 --> 00:48:14.710
Bogdan Mircea: you have to do something with it. I don't know if this is the only case. But I'm certain that there are a lot of instances where you're supposed to kind of send the problem report

335
00:48:15.070 --> 00:48:18.199
Bogdan Mircea:  without necessarily meaning that

336
00:48:18.580 --> 00:48:34.220
Bogdan Mircea: your protocol is terminated like, Okay, yeah, your use case is valid. But I I then it might well be the other use case where the other party sent the wrong message and you send them a problem report so they can be aware of the problem

337
00:48:34.270 --> 00:48:35.940
Bogdan Mircea: or I don't.

338
00:48:36.070 --> 00:48:44.050
Patrik Stas: Well, I think once the problem report is sent like it's it's it's

339
00:48:46.570 --> 00:48:52.069
Patrik Stas: I don't think those I I haven't seen protocol, which is kind of like, have this kind of

340
00:48:53.360 --> 00:49:05.900
Patrik Stas: oh, recovery kind of stuff in it, or like it. It. It sounds like I mean, it sounds great, like very robust, but I don't think the actually in Aries community right now, there's

341
00:49:06.170 --> 00:49:08.180
Patrik Stas: this kind of

342
00:49:11.330 --> 00:49:16.550
Patrik Stas: you know, even in the on the Rfc level, typically, when the problem re report is sent.

343
00:49:16.690 --> 00:49:21.899
Patrik Stas: Then you switched state some sort of failed state, and it's kind of the end

344
00:49:28.880 --> 00:49:35.050
Bogdan Mircea: I'm looking right now with the credential issues. 1 point. Oh.

345
00:49:35.440 --> 00:49:40.280
Bogdan Mircea:  hold on

346
00:49:40.630 --> 00:49:42.420
Bogdan Mircea: for these diagrams.

347
00:49:45.760 --> 00:50:13.370
Patrik Stas: And well, actually, you know, in those diagrams, they don't really even like I mentioned the unexpected conditions like, there's a problems report like taking a place there. They are mentioned in the issue credentials, 0 0 36, for example. But if you get a nonsense, they they didn't like draw in the diagram the kind of cases which cases like, if you get a nonsense message, you send a problem report. You know.

348
00:50:13.560 --> 00:50:19.310
Bogdan Mircea: I mean, they said something like if an issue might offer a credential for a price that the holder is unwilling to pay.

349
00:50:20.590 --> 00:50:26.030
Bogdan Mircea: All errors are modeled with the problem. Report message easy to anticipate errors. We set the flow.

350
00:50:26.200 --> 00:50:32.220
Bogdan Mircea: I think I'm still showing my screen. Atlanta. Okay, let me maybe bring this out here.

351
00:50:32.520 --> 00:50:33.300
Patrik Stas: Hmm.

352
00:50:34.690 --> 00:50:35.560
Bogdan Mircea: all right.

354
00:50:41.330 --> 00:50:43.149
Bogdan Mircea: insurance abandoned.

355
00:50:46.230 --> 00:50:47.950
Bogdan Mircea: So does that mean that

356
00:50:57.050 --> 00:51:02.529
Bogdan Mircea: hmm. okay. well. sure enough, so

357
00:51:04.080 --> 00:51:12.769
Bogdan Mircea: we could argue that, then there's like, if you get a retrial, or there's not even a a, a problem report to send. You might want to send a problem report if

358
00:51:12.890 --> 00:51:15.470
Bogdan Mircea: you get to that completely failed state.

359
00:51:15.560 --> 00:51:25.800
Patrik Stas: Yeah, I I think so because you receive bad input, right? And you want to tell them all, okay, if you send me like.

360
00:51:26.210 --> 00:51:28.160
Bogdan Mircea: fair enough. Yeah, it does make sense.

361
00:51:28.430 --> 00:51:31.510
Bogdan Mircea:  okay?

362
00:51:32.080 --> 00:51:33.290
Bogdan Mircea: So

363
00:51:33.690 --> 00:51:40.489
Bogdan Mircea: I guess then in that case it would be something like, I don't know. Maybe this error, and then maybe

364
00:51:41.500 --> 00:51:44.329
Bogdan Mircea: and then

365
00:51:47.110 --> 00:51:57.010
Bogdan Mircea: I don't know. maybe an option problem report and this is a generic here because the connection protocol uses a different problem report  

366
00:51:57.990 --> 00:52:03.950
Bogdan Mircea: and you might not necessarily generate the problem. We port out of this. So I guess, having it as an option is a good idea.

367
00:52:04.320 --> 00:52:09.880
Bogdan Mircea:  okay. So so there's that.

368
00:52:10.890 --> 00:52:16.039
Bogdan Mircea: yeah, that's basically the the overall idea of this

369
00:52:16.490 --> 00:52:18.270
Bogdan Mircea: and I think that would make it

370
00:52:18.640 --> 00:52:24.090
Bogdan Mircea: it would. It would come with less cognitive complexity. Because

371
00:52:24.230 --> 00:52:26.050
Bogdan Mircea: and all these cases like

372
00:52:26.080 --> 00:52:33.089
Bogdan Mircea: these things can. These are the things that can happen out of the state machine, of any state machine, of any protocol. Right? So

373
00:52:33.180 --> 00:52:42.949
Bogdan Mircea: whatever you like, whatever you're doing, or whatever protocol you're in, or state machine or in or whatever message you're processing. These are pretty much the outcomes that you're gonna be facing.

374
00:52:43.370 --> 00:52:47.080
Bogdan Mircea:  I think it makes it

375
00:52:48.440 --> 00:52:55.710
Bogdan Mircea: easier for consumers, especially to kind of a reason with what they need to do

376
00:52:56.030 --> 00:53:07.070
Bogdan Mircea: based on the outcome as well as kind of making them do something with the outcome and not not just getting a there. And okay, I'm just gonna question, mark that. And

377
00:53:07.900 --> 00:53:09.710
Bogdan Mircea: this is this, is it?

378
00:53:10.370 --> 00:53:15.539
Patrik Stas: Yeah, yeah, that I mean, it sounds good. Now, let's

379
00:53:15.920 --> 00:53:28.899
Patrik Stas: Sync up with mirror. And like you kind of what do you think about this? What? What kind of he also? I I I know. I remember he also has some sort of State mission result kind of structure, you know.

380
00:53:29.100 --> 00:53:35.469
Bogdan Mircea: I don't. I don't remember exactly what it looks like, so we can kind of compare it and discuss for it.

381
00:53:36.900 --> 00:53:51.019
Bogdan Mircea: Yeah. And maybe we can discuss a bit about the the other topic. and essentially, I'm I'm thinking about. I've been thinking since the the discussion yesterday about the fact that

382
00:53:51.290 --> 00:53:55.750
Bogdan Mircea: we are kind of making a library, whereas the other people are making a framework.

383
00:53:55.880 --> 00:53:57.030
Bogdan Mircea: and

384
00:53:58.050 --> 00:53:59.860
Bogdan Mircea: when you think about it.

385
00:54:00.910 --> 00:54:14.849
Bogdan Mircea: I think it might be there might be a fairly good reason why everybody else is making a framework and not a library. And I think it's because essentially, there are quite a limited amount of what's called the moving parts.

386
00:54:14.940 --> 00:54:16.010
Bogdan Mircea: And

387
00:54:16.170 --> 00:54:30.550
Bogdan Mircea: and all these and all this Aries ecosystem, I guess, like, okay, there are the protocol specifications. So the Protocols are kind of supposed to behave like whatever language you implement them. There's practically supposed to behave the way

388
00:54:30.590 --> 00:54:31.990
Bogdan Mircea: they are described there.

389
00:54:32.110 --> 00:54:38.689
Bogdan Mircea:  like the moving parts, would ultimately be. Maybe the ledger, the wallet

390
00:54:38.760 --> 00:54:42.699
Bogdan Mircea: the storage for the state machines.

391
00:54:43.940 --> 00:54:50.260
Bogdan Mircea: and whatever mechanism you use to receive and send a message. But apart from that.

392
00:54:50.810 --> 00:54:56.699
Bogdan Mircea: I don't really think there are other things that are. Let's say

393
00:54:58.130 --> 00:55:04.350
Bogdan Mircea: that there there were even be a reason to have to deal with other things. Apart from that.

394
00:55:04.570 --> 00:55:10.290
Bogdan Mircea: maybe there is more, but nevertheless it it. I think they are ultimately a limited amount of things.

395
00:55:10.530 --> 00:55:17.270
Bogdan Mircea:  so because I was thinking of, okay, this would be a uniform approach, and it would be

396
00:55:17.380 --> 00:55:21.300
Bogdan Mircea: of a less cognitive effort to to consumers.

397
00:55:21.490 --> 00:55:22.510
Bogdan Mircea: But

398
00:55:23.710 --> 00:55:27.439
Bogdan Mircea: ultimately, what if we could even make this

399
00:55:27.580 --> 00:55:30.339
Bogdan Mircea: less of a call for for users?

400
00:55:30.390 --> 00:55:33.489
Patrik Stas: I I think this is definitely something

401
00:55:33.960 --> 00:55:44.999
Patrik Stas: I think this was also made us concern, and like why he's so, you know he's coming back and forth. He's not satisfied, because I I feel like he find it too complicated. He he invented some sort of

402
00:55:45.050 --> 00:55:50.690
Patrik Stas: like small, helpful air on top of the State machine to make it easier for the consumers.

403
00:55:50.770 --> 00:56:03.060
Patrik Stas: But then, at the same time he did that. He didn't like the kind of you know inconsistency in the approach, like now, there's not like something new, something extra on top of that.

404
00:56:03.090 --> 00:56:22.510
Patrik Stas: It's a just a symmetry. It's not beautiful. and what you're saying, like, you know about library is a framework. Yeah, I think you're right. Maybe we'll eventually make a full per call, cause like we came from framework where you know we did like

405
00:56:23.830 --> 00:56:33.870
Patrik Stas: it was like super convey the you know the levy Cx is like it's supposed to be the original. It's it's supposed to be like it handled agency for you. It, like.

406
00:56:33.970 --> 00:56:44.849
Patrik Stas: you know, couple of the connection protocol with the agents you really didn't have to like. Think about some of integrating them. You didn't have to deal with like fetching the messages and stuff like that.

407
00:56:44.920 --> 00:57:06.229
Patrik Stas: But then, at the end of the day, we actually wanted to have that like kind of extra control. So we had to start like taking dial, start downloading a messages ourselves and then putting in manually to connection, you know, to connection State mission stuff like that, and that was desirable, because, like on the upper layers, we kind of needed that extra control to

408
00:57:06.230 --> 00:57:18.220
Bogdan Mircea: for for reasons to him. And but I honestly, don't think that's what makes the framework honestly right now, the difference between like, there's actually a kind of

409
00:57:18.710 --> 00:57:23.530
Bogdan Mircea: small and well-defined difference between us as a library, and

410
00:57:24.020 --> 00:57:28.710
Bogdan Mircea: there is Vcx as a framework, and that's particularly these

411
00:57:30.140 --> 00:57:34.460
Bogdan Mircea: I don't know. These are called state machines that consumers would have to deal with.

412
00:57:34.620 --> 00:57:39.749
Bogdan Mircea: and all these possible states, and all these possible results, and whatever?

413
00:57:40.260 --> 00:57:45.090
Because ultimately, like a framework like a library used in whatever way you want, a framework.

414
00:57:45.280 --> 00:58:01.719
Bogdan Mircea: does a well-defined thing with pluggable components right? And there's already we we already kind of have the plugable components pretty well defined like I said the ledger. The wallet. stuff like that that you can just provide yourself as a consumer.

415
00:58:02.330 --> 00:58:10.230
Bogdan Mircea: The only thing that's really standing between the the current state of the art, and and a more

416
00:58:10.740 --> 00:58:22.469
Bogdan Mircea: and a consumer-friendly approach? Or are these state machines and their complexity? But when you come to think about it like I like I was saying for I'm sure that

417
00:58:22.730 --> 00:58:29.369
Bogdan Mircea: most of the people that use this right now have used it, and we'll use it in the future.

418
00:58:29.480 --> 00:58:31.360
Patrik Stas: They will just want to think to work.

419
00:58:31.530 --> 00:58:44.569
Bogdan Mircea: And that kind of brings me to maybe having some sort of interface for handling messages, and it kind of ties to the way the messages create has been designed a bit.

420
00:58:44.950 --> 00:58:52.130
Bogdan Mircea: and it actually makes the state machines. it might end up making the same machine simpler, so

421
00:58:52.650 --> 00:59:01.930
Bogdan Mircea: kind of stick with me here a bit, but and it it might take a bit longer, so I don't know if you guys have time. If now, we can maybe discuss this next week. Okay.

422
00:59:02.360 --> 00:59:04.820
Bogdan Mircea:  So

423
00:59:05.680 --> 00:59:08.160
Bogdan Mircea: the the the over lifetime of

424
00:59:08.610 --> 00:59:13.440
Bogdan Mircea: of a message right would be, you get the message?

425
00:59:13.520 --> 00:59:16.670
Bogdan Mircea:  and then

426
00:59:17.090 --> 00:59:18.569
Bogdan Mircea: I don't know you.

427
00:59:19.560 --> 00:59:30.339
Bogdan Mircea: You might want to. You need to kind of see what message it is and get a state machine that's associated to that.

428
00:59:30.550 --> 00:59:44.710
Bogdan Mircea: I don't. That instance of the protocol that you got a message for. And if things match up, you basically, and you basically try to process. Sorry to process the message right?  and what that would mean is basically that

429
00:59:44.840 --> 00:59:56.830
Bogdan Mircea: you would have these message handlers that expect a particular message and a particular state machine. And given the fact that we use the type state pattern, the state machine would be in a particular state.

430
00:59:57.150 --> 00:59:58.310
Bogdan Mircea: So

431
00:59:58.960 --> 01:00:25.339
Bogdan Mircea: you basically put these things in. And that's where your messaging process. Yeah, your your message processing starts and we can actually separate. Remember how we were talking about the I O being in the state machine. And that's kind of messing things up because the state machines are consuming. Well, what if you actually could do the I O in here, but outside of the in transition and the State machine machine transition would pretty much become infallible.

432
01:00:25.440 --> 01:00:39.879
Bogdan Mircea: because you first try to gather all the pieces that you need to get to the next state. If that fails, you never even touch the state machine right? So there's no need to basically take it out and put it back, or return the old state, or do whatever you need to do.

433
01:00:39.950 --> 01:00:44.279
Bogdan Mircea: like this whole. This whole thing was would essentially just

434
01:00:44.690 --> 01:00:45.970
Bogdan Mircea: not happen.

435
01:00:46.040 --> 01:00:52.549
Bogdan Mircea:  because all the all the I and all the failures that can occur essentially

436
01:00:52.570 --> 01:00:55.200
Bogdan Mircea: happen, a layer on top of the state machine

437
01:00:56.150 --> 01:01:03.429
Bogdan Mircea: and the state machine would basically be there just to keep track of, like where we are in the protocol, which in the end, that's what state machines are for?

438
01:01:04.280 --> 01:01:18.629
Bogdan Mircea:  Yeah. So now the beauty of this, in a way, would be, we can provide sort of like default built in implementations of of these message handlers for all the messages that we.

439
01:01:18.740 --> 01:01:20.390
Bogdan Mircea: you know, support

440
01:01:20.490 --> 01:01:34.050
Bogdan Mircea: all the States of the State machines which we will ultimately do anyway, will we just incorporate that in the state machine itself. But people could maybe also provide their own like, if you want to override or just use something else

441
01:01:34.090 --> 01:01:45.090
Bogdan Mircea: for a particular message, or you might wanna, I don't know. Process decorators differently or something like that. Then you could provide your own implementation and just not use the one

442
01:01:45.510 --> 01:01:49.270
Bogdan Mircea: from the framework or the library, whatever you want to call it.

443
01:01:50.160 --> 01:01:59.990
Bogdan Mircea:  And this would even abstract away all this stuff in in in a way, because I'm thinking that if we go to this.

444
01:02:00.060 --> 01:02:06.929
Bogdan Mircea: if you go, if we go this route to simplify things, we could even have this kind of state machine handler.

445
01:02:06.940 --> 01:02:15.630
Bogdan Mircea: The interface of this is debatable again. This removed thing was maybe in the I know, considering the fact that you might want to remove a failed state machine. But this can

446
01:02:15.820 --> 01:02:24.690
Bogdan Mircea: just as well go away. And what do you do? You just insert it with the failed state. And if the user wants to do something with that and remove it. They can do it later on. It's their problem.

447
01:02:25.220 --> 01:02:32.830
Bogdan Mircea:  but basically, given this this handler in this process. We just

448
01:02:33.560 --> 01:02:37.160
Bogdan Mircea: take the state like we try to process the pieces before

449
01:02:37.220 --> 01:02:40.980
Bogdan Mircea: the pieces needed to transition the state machine, and then we get it.

450
01:02:41.260 --> 01:02:44.190
Bogdan Mircea: and then we insert it and

451
01:02:44.270 --> 01:02:57.110
Bogdan Mircea: decide what to do, what to do later on. Now, this is not a final, obviously, just I I literally thought of this this morning. So there's a lot of things to figure out like what to do with. I know problem reports and stuff like that. It's

452
01:02:57.200 --> 01:02:59.350
Bogdan Mircea: still needs to be thought of.

453
01:02:59.490 --> 01:03:04.320
Bogdan Mircea: But ultimately, what this would lead up to is that when you get a message.

454
01:03:04.620 --> 01:03:16.429
Bogdan Mircea: okay, you got a match on it to kind of. See. Okay what this message is and what you're supposed to do with it. But then you just pass in the message handler. You already have the message right? Because you matched on it.

455
01:03:16.520 --> 01:03:21.289
Bogdan Mircea: You provide a state machine handler that will give you a state machine a particular state.

456
01:03:21.460 --> 01:03:36.969
Bogdan Mircea: You might want to provide the I don't know. It's the one that will take you to state machine out of whatever storage or cache you have, and the one that's going to put it back. And we need an as an extraction. We need an abstraction over there because

457
01:03:37.050 --> 01:03:43.019
Bogdan Mircea: the state machines, like each individual individual State machine and each individual state has a different type. So

458
01:03:43.220 --> 01:03:53.389
Bogdan Mircea: it will be best to kind of have that outside. Now here, this is a basically the Id. I don't know if we necessarily need it to be generic, we might just use string. We might not. I don't know

459
01:03:54.120 --> 01:03:57.090
Bogdan Mircea:  But

460
01:03:57.310 --> 01:03:59.969
Bogdan Mircea: ultimately, ultimately the idea is that

461
01:04:00.350 --> 01:04:06.420
Bogdan Mircea: we can handle through this interface. The State machine handler we can take care of.

462
01:04:06.920 --> 01:04:18.520
Bogdan Mircea: you know, depending on the outcome of the State machine, whether you get the new or the old one we can handle putting it just putting it back. You know, we can get it in the old State. We have all the pieces.

463
01:04:18.870 --> 01:04:21.500
Bogdan Mircea: we transition it. And then we put it back.

464
01:04:21.760 --> 01:04:34.590
Patrik Stas: There's there's one more yeah, it's it's interesting idea. I mean, typically, I would just need to. you got a message. the State mission handler.

465
01:04:35.630 --> 01:04:47.969
Patrik Stas: And so that's style machine handler. However, it needs to. based on the message it needs to find that message in whatever storage it's stored.

466
01:04:48.580 --> 01:05:02.399
Patrik Stas: I need to find a state machine based on the message that can be sometimes based on the message Id sometimes can be based on thread id, sometimes. Maybe I I guess there, there might be few cases.

467
01:05:02.470 --> 01:05:12.269
Patrik Stas: Okay, let's see. So it it finds the message. It needs to understand the store. It needs to understand how the state machines are stored in that store.

468
01:05:13.120 --> 01:05:16.289
Bogdan Mircea: right? Which is what this handler is for

469
01:05:16.310 --> 01:05:23.950
Patrik Stas: and save it. But okay, I I see, like, maybe 2 kind of problems. First, is that

470
01:05:25.560 --> 01:05:26.820
Patrik Stas: my schedule?

471
01:05:30.800 --> 01:05:37.480
Patrik Stas: There might be bit of a like inefficiency like, since this is doing like stuff for you.

472
01:05:38.630 --> 01:05:40.490
Patrik Stas: Okay.

473
01:05:40.740 --> 01:05:43.710
Patrik Stas: like, First of all.

474
01:05:49.970 --> 01:05:57.080
Bogdan Mircea: sorry, I'm just quiet. And this is all to take in. And you definitely need to think about it and

475
01:05:57.340 --> 01:06:10.249
Bogdan Mircea: complete. So you'll need other pieces here. You might need, I know, a ledger type or wallet type, some stuff like that. So there are other pieces that are needed. But the point.

476
01:06:11.250 --> 01:06:12.370
Bogdan Mircea: yeah, go ahead.

477
01:06:12.380 --> 01:06:19.210
Patrik Stas: like, I guess the main thing I'm like, I think I'm considering is

478
01:06:19.360 --> 01:06:24.199
Patrik Stas: a users like might have like different

479
01:06:26.660 --> 01:06:41.250
Patrik Stas: like, you might want to have more data associated with the State machine, for example, than just the State mission. So like you want to. Maybe do some, you know, since, especially since we have this the of like, you shouldn't care about what to realize.

480
01:06:41.280 --> 01:06:52.370
Patrik Stas: You know what serialize state machine looks like. Then, if you want to, for example, keep a you know, like some database of this, I know.

481
01:06:52.370 --> 01:07:11.760
Patrik Stas: prove our state machines, and you want to track for each of them like number of attributes like, was it verified? what does the values provide it? And you know. Maybe you want to have indices on this field, so we can like do for filtering and searches and stuff like that. Then

482
01:07:12.100 --> 01:07:17.410
Patrik Stas: then I'm worried like like the this gonna dictate too much.

483
01:07:17.460 --> 01:07:31.480
Patrik Stas: If the State mission handler this, this could get in search thing is not gonna dictate too much about how the you know the database schema, or you know Mongo collection, or whatever must look like

484
01:07:31.640 --> 01:07:35.709
Patrik Stas: And I guess there's like some

485
01:07:35.900 --> 01:07:36.710
Patrik Stas: sorry.

486
01:07:36.890 --> 01:07:38.159
Bogdan Mircea: Why would it?

487
01:07:38.940 --> 01:07:55.310
Bogdan Mircea: it's it's still a trade. You implement this on a type. And you could have, you could store whatever you wanted to type. And you can design the methods to look exactly like you want, like you don't necessarily. You were talking about, you know, storing some other metadata.

488
01:07:55.610 --> 01:08:04.619
Bogdan Mircea: If you could do that in this exact same method. Now, again, probably these are going to be asing trades as well. I literally just drive to this. So

489
01:08:04.690 --> 01:08:09.409
Bogdan Mircea: I I I can imagine, like this being like,

490
01:08:10.330 --> 01:08:18.939
Patrik Stas: convenient. Yeah, when you're staying in a rust you call system really like you're writing on top of this in R. That must be great.

491
01:08:19.100 --> 01:08:21.080
Patrik Stas: or at least could be great.

492
01:08:21.439 --> 01:08:30.610
Patrik Stas:  I wonder I I I see that they will be like a lot more difficult to work with. kinda

493
01:08:30.859 --> 01:08:37.110
Patrik Stas: and we're work with. If you go through. If a file, let's see. You know you have a layers between. No J in Javascript. and

494
01:08:37.430 --> 01:09:01.150
Patrik Stas: then you have some like database handling inside. R. But then maybe you have some own, you know, in Javascript as well. It's kind of what you know what's happening. And and but yeah, okay, like, anyway, long term, like, kind of first classes, citizen is the rest. And we are planning to like, you know, a long term if you want to ride like if you're very far in the.

495
01:09:01.189 --> 01:09:14.650
Patrik Stas: So this could be like pretty cool. But if this is like some, if it is like the handler. This stuff becomes kind of like, you know, literally like, this is a Dcx. And and

496
01:09:15.850 --> 01:09:27.330
Patrik Stas: then I'm thinking also. Then, yeah, it wouldn't be great, for if I, and especially since lots of people are coming from from the Mobile, I wonder who how this kind of

497
01:09:27.689 --> 01:09:49.919
Patrik Stas: you know how these would play with them. I don't know how they typically store the state machines. I think I think maybe sure would have some interesting in in assault on this. I I wonder what he would think, how how convenient, from his perspective or inconvenient. I don't know. Would it be you have this kind of handler, and, you know, kind of

498
01:09:50.430 --> 01:10:06.279
Patrik Stas: deal with persistence on the on on that level. May, because I'm thinking, like, maybe you know, maybe when George is working with state machines. Maybe he's putting into some kind of Ios store, you know.

499
01:10:06.330 --> 01:10:20.019
Patrik Stas: If he's if he's doing that from like upper levers somewhere, he gets a he's a message. He's the state machine. And then he puts it into some sort of you know Ios system store, and we don't want to deal with.

500
01:10:20.020 --> 01:10:40.330
Bogdan Mircea: I I don't know. I I imagine we I I don't know what to support for, like Ios stuff, you know, from Rus. If you can even do that if you would even be able to write it. Kind of handle for a bit for a bit, and I can give you the example of the Cx. so that's what we don't live. The Cx. If I could find it.

501
01:10:40.550 --> 01:10:54.429
Bogdan Mircea:  it's somewhere around here the on the core, right? So in in let me seex right now, what is it? Handle connection? Okay.

502
01:10:55.180 --> 01:11:02.969
Bogdan Mircea: in the v, 6, what you actually have is you have these, this cache where you store your objects, and I believe,

503
01:11:03.130 --> 01:11:10.659
Bogdan Mircea: there were some functions for serializing. And this realizing right stay machine

504
01:11:11.260 --> 01:11:14.410
Bogdan Mircea: that that could be your state machine handling.

505
01:11:14.520 --> 01:11:26.769
Bogdan Mircea: You don't necessarily have to store this in the database if you don't want to. Some type which has some other methods that that look like these, you know, basically copy. Paste these into your type.

506
01:11:26.890 --> 01:11:29.339
Bogdan Mircea: You expose them to ffi, if you want.

507
01:11:29.380 --> 01:11:44.209
Bogdan Mircea: and that's it. And you do whatever you want in the I I don't think this is not flexible enough. I think this is actually. you know, very flexible. And even the message handler. You can write your own. If you have a particular use case

508
01:11:44.350 --> 01:11:56.789
Bogdan Mircea: and just process. But then you you, it's basically a conscious decision that you make that you know what this. The the implementation that these guys provide is not suitable for me, and I want to do some other crazy stuff

509
01:11:56.920 --> 01:12:00.220
Bogdan Mircea: with with the message or whatever.

510
01:12:00.480 --> 01:12:02.079
Bogdan Mircea: and that's your business.

511
01:12:02.160 --> 01:12:04.480
Bogdan Mircea:  But

512
01:12:05.240 --> 01:12:07.070
like, I said, if you think about it

513
01:12:07.220 --> 01:12:13.200
Bogdan Mircea: ultimately, what most people will do is they're gonna match on the message and

514
01:12:13.730 --> 01:12:22.760
Bogdan Mircea: and then do the whatever state machine transition, and then handle this result. And what else needs to be done like it's in in. I don't know. Maybe 100

515
01:12:24.180 --> 01:12:36.789
Bogdan Mircea: erez agmoni, 90 out of 100 repository. That would be repositories that would be implementing our library. They would all do this exact same thing which we could abstract away make their lives easier. And also one.

516
01:12:36.970 --> 01:12:45.589
Bogdan Mircea: you know, because for us it's easy to deal with with this kind of thing. We're the developers. We know what it means. But consumers, I can guarantee you. They're going to ask about it a lot.

517
01:12:48.200 --> 01:12:59.799
Patrik Stas: Okay? Oh, maybe let's let's not stretch it off for too long. I I feel like this could be a lot longer. But let's also get like George on this. And then.

518
01:12:59.880 --> 01:13:15.279
Patrik Stas: like, I like my just my May comes from. It's like, maybe people want to do like storage and resistance from their respective domain, whether it's in like Java or dials word node is, or or maybe I I don't know

519
01:13:15.520 --> 01:13:30.659
Patrik Stas: that that's my concern. And maybe then, second second concern is like, actually And and what's yeah. Those could be another, I guess, like, for for discussion with a another thought is like possible complication is like

520
01:13:30.840 --> 01:13:36.249
Patrik Stas: when you get the message. Typically like you passed that message to the State machine

521
01:13:36.990 --> 01:13:39.709
Bogdan Mircea: and then, based on

522
01:13:40.010 --> 01:13:51.509
Patrik Stas: if, like the processing somewhat completed, you know, you know you. You once you know that the message has been processed by a state mission and you got some result.

523
01:13:51.520 --> 01:14:10.130
Patrik Stas: Then you want to, you know, using a pickup protocol, this kind of stuff. You want to update the mediator that you know you want to update the step status of the message that you don't want to no longer process it in his that has been processed. So maybe that will also have to be kind of considered and thought of.

524
01:14:10.270 --> 01:14:16.270
Patrik Stas: If that can be abstracted away, or you know, how can we? Or how can we

525
01:14:16.790 --> 01:14:17.990
Patrik Stas: support it?

526
01:14:20.260 --> 01:14:26.850
Bogdan Mircea: but I think that can basically also happen outside of this.

527
01:14:26.870 --> 01:14:27.970
Bogdan Mircea: So

528
01:14:30.770 --> 01:14:38.149
Bogdan Mircea: I don't know, like you could, probably, and we're most likely you would return some sort of a result here.

529
01:14:38.200 --> 01:14:39.840
Bogdan Mircea: So if you got in there.

530
01:14:40.230 --> 01:14:44.999
Bogdan Mircea: you might not want to update the whatever the message in the

531
01:14:45.350 --> 01:15:03.279
Patrik Stas: in the mediator. But if you did get an okay or whatever, then you can update it and say that it's processed

532
01:15:03.710 --> 01:15:13.889
Patrik Stas: like, you know, that you didn't succeed. The state machine stayed in the previous state. But you just want to, and you will need to, like, you know, get a message again.

533
01:15:14.180 --> 01:15:22.800
Bogdan Mircea: Yeah, that's that's a good point. I think I actually thought about that. But it's my mind. Yeah, you probably want kind of the same thing in here.

534
01:15:22.900 --> 01:15:32.989
Bogdan Mircea: But without dealing with the state machine. Right? So you just want to. Okay, this is retrial. You can. You can retry later. And this is the error, or it's aborted. And

535
01:15:33.110 --> 01:15:35.240
Bogdan Mircea:  you know.

536
01:15:35.520 --> 01:15:39.129
Bogdan Mircea: or it's okay, like, the the message was processed successfully.

537
01:15:39.500 --> 01:15:41.560
Patrik Stas: so it could be something like that.

538
01:15:41.670 --> 01:15:46.729
Bogdan Mircea: and it will actually make sense, especially in in the use case you provided

539
01:15:46.910 --> 01:15:48.400
Patrik Stas: I think it's a very good point.

540
01:15:48.980 --> 01:15:54.999
Bogdan Mircea: But nevertheless, like, even if if and if you do something like that, I think not. Having to deal with the State machine

541
01:15:55.190 --> 01:15:58.569
Bogdan Mircea: is a big win for most of the consumers.

542
01:16:10.400 --> 01:16:26.050
Patrik Stas: Well, I'll I'll I'll think about it. And yeah, I mean, I guess we well, let's think about it more I need to kind of get you through my mind, and and maybe take some time to process. That's a that's a good idea, though, and

543
01:16:26.670 --> 01:16:28.029
Patrik Stas: I mean

544
01:16:30.780 --> 01:16:39.119
Patrik Stas: I'm I'm I'm I'm I'm saying, like, you know, that we found out so as a library, which I think is the case at the moment

545
01:16:39.190 --> 01:16:45.020
Patrik Stas: pretty much. But I I I can imagine, like having some like

546
01:16:46.280 --> 01:16:55.259
Patrik Stas: right there, a thing layer on top of like this, like the these like library components, we have state machines

547
01:16:55.310 --> 01:16:58.379
Patrik Stas: to like offload something, and then

548
01:16:59.410 --> 01:17:18.820
Patrik Stas:  that could be like easier to use. But at the same time there will be still those like granular components underneath that if somebody may. And what I, what I'm trying to get at is that then we can basically design the state machine is in a simpler fashion.

549
01:17:18.840 --> 01:17:22.199
Bogdan Mircea: you know, with the like completely

550
01:17:22.350 --> 01:17:38.850
Bogdan Mircea: without I/O, because we would do them here. And people would also have an example like, you know, maybe more seasons, developers that want to do stuff their own way. They would also have an example of what they need to do and how it needs to look like, and how it works to kind of do it themselves if they want to.

551
01:17:39.130 --> 01:17:41.950
Bogdan Mircea: and I know they want to have have no handlers.

552
01:17:42.050 --> 01:17:51.700
Bogdan Mircea:  like I. I don't think it's necessarily taking power out of people's hands, but as much as enabling them to kind of get things working

553
01:17:51.870 --> 01:17:52.900
Bogdan Mircea: faster.

554
01:17:53.180 --> 01:18:06.019
Bogdan Mircea: and also kind of making our whole code much easier to to reason with, because the state machines right now do a lot of things, and that it's kind of painful.

555
01:18:07.210 --> 01:18:13.450
Bogdan Mircea: whereas here we have the possibility of kind of layering things out in a much easier to follow away.

556
01:18:14.830 --> 01:18:18.770
Bogdan Mircea: and a much organized matter of dealing with the state machines as well.

557
01:18:20.150 --> 01:18:20.860
Patrik Stas: Hmm.

558
01:18:21.580 --> 01:18:26.890
Patrik Stas: oh, yeah, that I mean the I/O must be somewhere. It's not. Is is the I of

559
01:18:26.980 --> 01:18:39.009
Bogdan Mircea: yeah, no, it would be here. But this doesn't necessarily have anything to do with the state machine until it transitions itself. So where it transitions it. So, for instance, like I was saying here you would do whatever

560
01:18:39.340 --> 01:18:43.219
Bogdan Mircea: I don't know. Take take any, any, any transition that you want, so

561
01:18:43.270 --> 01:18:46.410
Bogdan Mircea: why can it fail? It can fail? Because I know

562
01:18:46.870 --> 01:19:03.040
Bogdan Mircea: some some stuff just doesn't add up, or some I/O er, or whatever. Now, all these errors that can occur would be happening before you actually try to transition the State machine, the transition, the function on the state machine would only take the parameters it needs

563
01:19:03.170 --> 01:19:11.040
Bogdan Mircea: and compose the next State. An infallible operation. But the the fallability is basically taken out

564
01:19:11.240 --> 01:19:29.249
Bogdan Mircea: of the transitioning function, and into this, or maybe some other functions that this this thing calls. So then you no longer, I know. Return the old state, or whatever you do, and or transition to whatever it it's it's much easier to follow, I think.

565
01:19:29.680 --> 01:19:30.390
Hmm.

566
01:19:31.430 --> 01:19:38.230
Patrik Stas: yeah, you you might. You might have some point, and I mean, still it would. Still, that's a good point that you

567
01:19:39.030 --> 01:19:58.369
Patrik Stas: so that you can still, for example, integrate this with with Vcx, which we want to keep the Nodej support, and just to message hand, or from technically just for B for the in-memory cache, and then you can do persistence in the database your whatever your own way.

568
01:19:58.550 --> 01:20:05.779
Bogdan Mircea: right? And it's a difference also a thing to maybe note about this is that the handle like the state machine handler.

569
01:20:06.150 --> 01:20:18.799
Bogdan Mircea: any any state machine handler can basically be passed in here because it it's a generic one, the function. And it's not an associated type like these things are. so if you just want to store your state machine differently.

570
01:20:18.890 --> 01:20:31.819
Bogdan Mircea: feel free to do it. Like I, I actually believe this is something consumers would implement. We wouldn't implement something for them. So you might have a different database, or you might have whatever. So this is something that consumers would implement and just pass in here.

571
01:20:31.830 --> 01:20:35.019
Bogdan Mircea: just as maybe the transport. Now this some.

572
01:20:35.040 --> 01:20:48.569
Bogdan Mircea: There's also a matter of debate. I know we're kind of stretching, but whether given this this idea, we could still have maybe keep this transport trade and have them, or maybe just taking a closure

573
01:20:48.600 --> 01:20:52.530
Bogdan Mircea: and also send messages or try to send messages from here.

574
01:20:52.560 --> 01:20:59.719
Bogdan Mircea: or maybe problem reports. Only I don't know. And then people could still retry the message, sending afterwards

575
01:20:59.850 --> 01:21:02.500
Bogdan Mircea: so kind of making things more

576
01:21:03.540 --> 01:21:09.480
Bogdan Mircea: streamlined. I don't know this. It's we're stretching again, so there's a lot to discuss about this, but

577
01:21:09.790 --> 01:21:13.049
Bogdan Mircea: I just wanted to kind of present the what I what I was thinking about

578
01:21:15.990 --> 01:21:22.899
Bogdan Mircea: this would, sorry. Can you? Can you share it for back back for 2 more minutes.

579
01:21:23.000 --> 01:21:25.820
Bogdan Mircea: Okay, sure, you get some loss

580
01:21:26.180 --> 01:21:49.230
Patrik Stas: concludes and last thoughts. Just gonna that great do kind of a little brain dump on my my own. so there'll be the still mission and the message handle. It gets message because it's the handler handler can get message from somewhere story back there.

581
01:21:50.720 --> 01:21:56.680
Patrik Stas: Okay, so, and we have, pretty much, we can share the same handler, for

582
01:21:57.590 --> 01:22:05.749
Patrik Stas: I guess in pretty much the same handle for many different State machines, maybe different configurations.

583
01:22:05.840 --> 01:22:08.929
Patrik Stas: So I want to store different state machines and

584
01:22:09.280 --> 01:22:14.980
Patrik Stas: different tables or collections or files, whatever.

585
01:22:15.720 --> 01:22:22.579
Patrik Stas: And then you get a message. You you process that. And this thing

586
01:22:22.820 --> 01:22:34.410
Patrik Stas: you you get the let's say you get the what's interesting message. We got a connection. Request message you, you get the handler, for

587
01:22:34.990 --> 01:22:37.710
Patrik Stas: we got a handle of for connections.

588
01:22:39.370 --> 01:22:55.309
Patrik Stas:  basically for that type of message. You might not even expect to find anything, because somebody simply send you a connection with this out of blue.

589
01:22:55.580 --> 01:23:00.270
Patrik Stas: So in that case you will actually in in that pro, in that

590
01:23:00.780 --> 01:23:02.210
Patrik Stas: processing.

591
01:23:02.290 --> 01:23:06.380
Patrik Stas: you will actually get something. But you would process the message.

592
01:23:06.480 --> 01:23:20.530
Patrik Stas: create the state machine. It would insert the staying machine. You will have to. actually. you might actually. once I guess the in search.

593
01:23:22.250 --> 01:23:25.560
Patrik Stas: the inserts. In that case

594
01:23:25.610 --> 01:23:34.880
Patrik Stas: the inserts to actually like a return some sort of id and then process process, I guess. Should also kind of

595
01:23:35.480 --> 01:23:45.120
Patrik Stas: propagated because it creates some new new new recording database. You want the caller about some control information about it?

596
01:23:45.970 --> 01:23:50.610
Patrik Stas: So that'll be like actually interesting case.

597
01:23:51.330 --> 01:24:02.919
Patrik Stas: But then what happens? Then? You get that request you in the processing message. Okay, so you create some placeholder state machine in initial state. It it's a connection, a request to

598
01:24:02.990 --> 01:24:15.679
Patrik Stas: maybe have to resolve their did. Maybe it's somewhere on some ledger, or whatever they it can be pretty much anything. So you do the id resolution in the processing

599
01:24:15.950 --> 01:24:22.139
Patrik Stas:  you within the what? So this on some ledger I O, you.

600
01:24:23.010 --> 01:24:31.619
Patrik Stas: create the keys in your wall at some what I O, and then, lastly, like, you, generate the response for this.

601
01:24:32.170 --> 01:24:48.679
Patrik Stas:  generate the response connection, response, message. You send it. You find that sending message fail because you are out of Internet connection. Temporarily.

602
01:24:48.780 --> 01:24:52.980
Patrik Stas: you might have some, I guess, retrial logic. And

603
01:24:53.480 --> 01:24:59.530
Patrik Stas: I guess the processor that's the kind of thing which would be probably conf configurable.

604
01:25:00.520 --> 01:25:02.869
Bogdan Mircea: so

605
01:25:03.010 --> 01:25:15.679
Bogdan Mircea: I'm sorry for interrupting. I think we can at best try to send it once, and people can try to resend it later on, like we're still gonna generate the message. That's it's still gonna be the way the State machines would be. So you generated the response to a connection request

606
01:25:15.860 --> 01:25:29.120
Bogdan Mircea: you transition to state machine. It contains the response. We can try to send it once, but then people can also retrieve the state machine from the database themselves, maybe have some sort of background tasks that

607
01:25:29.130 --> 01:25:44.699
Patrik Stas: I don't know if you didn't. If you don't get the response to your last reply for, or if it's stay machine being updated in 2 days, then maybe try to resent the message. If there is a message to resent

608
01:25:45.460 --> 01:26:13.270
Patrik Stas:  we would still keep that constraint of not doing like the send response I/O. In the process method. We would, only we could do it once, but we don't guarantee that they will actually, you know, do anything or like. I said the the thing with the the State machine states is that we? We can send the message, but we'll never have the confirmation that it was received

609
01:26:14.930 --> 01:26:15.990
Bogdan Mircea: so

610
01:26:16.180 --> 01:26:17.369
Patrik Stas: by all.

611
01:26:17.510 --> 01:26:27.479
Bogdan Mircea: and we might have, like the the thing with having the ability to send messages here is that it might be convenient in the case that we get the a problem report that we

612
01:26:27.650 --> 01:26:31.050
Bogdan Mircea: it might need it to be sent so we could give that to users.

613
01:26:31.440 --> 01:26:40.250
Bogdan Mircea: Hmm, actually, you know what? That might be a better idea. Okay, maybe we don't do any message sending it all. Maybe we just give the resulting messages to the user. So

614
01:26:40.370 --> 01:26:41.200
Bogdan Mircea: good point.

615
01:26:42.420 --> 01:27:02.289
Patrik Stas: because then you would have to. If you. If there's like 2 outcomes of process like you get connection, request. And basically there's 2 outcomes like either the response or send or not send. Did I imagine, after after after calling process and use a call, I check what actually happened, which state I am, and if I'm not in the

616
01:27:02.620 --> 01:27:03.550
Patrik Stas: you know

617
01:27:03.950 --> 01:27:07.319
Patrik Stas: the I know state which signals

618
01:27:07.400 --> 01:27:09.370
Patrik Stas: successful sending.

619
01:27:09.980 --> 01:27:18.990
Patrik Stas: Then I have to kind of retry myself, possibly, or you trial nature, and that's kind of like complexity. So yeah, I think that

620
01:27:19.030 --> 01:27:23.720
Bogdan Mircea: message sending out keep it out of the process

621
01:27:23.820 --> 01:27:32.829
Patrik Stas: if you wanna make it responsible. So so in that case this would encapsulate the ledger.

622
01:27:32.980 --> 01:27:37.780
Bogdan Mircea: And yeah, like getting the pieces.

623
01:27:38.940 --> 01:27:39.800
Bogdan Mircea: Sorry.

624
01:27:40.210 --> 01:28:05.010
Patrik Stas: Yeah. So this process method will basically encapsulate like database read and right of the state machine before and after. In the in the middle there'll be processing of the received message, possibly some sort of like a ledger like interactions, and and like, what interactions

625
01:28:05.070 --> 01:28:06.799
Patrik Stas: generating?

626
01:28:08.070 --> 01:28:09.420
Bogdan Mircea: Okay?

627
01:28:14.020 --> 01:28:17.669
Patrik Stas: Yeah. And technically like, if you actually.

628
01:28:18.670 --> 01:28:24.020
Patrik Stas: if you actually don't, yeah, if you want,

629
01:28:24.210 --> 01:28:26.780
Patrik Stas: if you actually don't want.

630
01:28:27.450 --> 01:28:29.930
Patrik Stas: you know, the message.

631
01:28:29.960 --> 01:28:40.580
Patrik Stas: the the handler to deal with the database. You can always kind of provide really mock, come off state machine handler, which would

632
01:28:40.640 --> 01:29:02.210
Patrik Stas: basically do nothing like just memory slot somewhere, and it would try to mess, get the state machine and write it, or just write it. If nothing was there. In the first place, which is also the case with the connection request for you don't actually have you received the message, but you don't have any state machine to load up here?

633
01:29:02.640 --> 01:29:03.400
Bogdan Mircea: Right?

634
01:29:08.650 --> 01:29:13.699
Patrik Stas: Yeah, this could maybe kind of like, provide that kind of uniform

635
01:29:14.000 --> 01:29:28.790
Patrik Stas: layer on double state machine. This thing, that mirror was coming up with. But but it didn't seem uniform. And like, it seems like a symmetric. Maybe this could be that kind of a shared interface.

636
01:29:28.890 --> 01:29:31.559
Bogdan Mircea: Yeah, definitely achieve it

637
01:29:32.420 --> 01:29:39.089
Patrik Stas: for the I O, which needs to be done on top of the machines. Since we want to.

638
01:29:39.650 --> 01:29:47.550
Bogdan Mircea: Yeah, I was thinking about the the framework. I think I think I mean in the end people would still have to do this themselves and match on the erase message and whatnot

639
01:29:47.580 --> 01:29:54.979
Bogdan Mircea: But I just think like the the overall, like we can abstract away some stuff that are really common

640
01:29:55.050 --> 01:29:59.740
Bogdan Mircea: are kind of our responsibility, and are not really something that

641
01:29:59.870 --> 01:30:02.569
Bogdan Mircea: consumers should deal with, you know.

642
01:30:03.130 --> 01:30:09.480
Bogdan Mircea: like the actual message processing while also making the whole interfaces nicer.

643
01:30:13.930 --> 01:30:20.259
Bogdan Mircea: more about it. Maybe you know, also consider what you said and all the possible use cases.

644
01:30:20.310 --> 01:30:23.859
Bogdan Mircea: Kind of drop the more completely. Api. But

645
01:30:25.730 --> 01:30:44.229
Patrik Stas: yeah, let's let's leave it. That's this. And I think we have lots of next week or something. No, and I think, this will be this, this must be like a compulsory listening for for charge. And I met up

646
01:30:44.290 --> 01:30:58.489
Patrik Stas: so they can do the inputs on this discussions. And and I think, like you are up to something and I think, like Middle also, like, I might also find some some parallels with the problems

647
01:30:58.510 --> 01:31:02.709
Patrik Stas: he was struggling in this process.

648
01:31:02.860 --> 01:31:09.730
Patrik Stas: a method which can, I would uniformly could potentially, uniformly encapsulate those.

649
01:31:09.890 --> 01:31:17.559
Patrik Stas: The the complexity you want to extract out of state machines put them somewhere on top, and maybe this message hand with that layer

650
01:31:18.380 --> 01:31:19.560
Bogdan Mircea: on the right.

651
01:31:20.250 --> 01:31:21.290
Patrik Stas: Okay.

652
01:31:23.170 --> 01:31:26.370
Bogdan Mircea: all right. That was that, was it, then.

653
01:31:26.620 --> 01:31:29.510
Patrik Stas: And I think we have one more item in the agenda.

654
01:31:30.390 --> 01:31:31.400
Patrik Stas: What's that?

655
01:31:31.670 --> 01:31:34.270
Patrik Stas: No, no, no, I don't think so.

656
01:31:34.320 --> 01:31:35.480
Patrik Stas: Good. Good.

657
01:31:35.770 --> 01:31:36.910
Bogdan Mircea: full solar.

658
01:31:37.210 --> 01:31:41.599
Patrik Stas: fortunately. Okay. So you guys are all free

659
01:31:41.830 --> 01:31:53.150
Patrik Stas: man, hopefully, I don't know a at least like you. You took something out of this. I I don't know. You are listening actively. It might be kind of like

660
01:31:53.330 --> 01:31:55.079
Patrik Stas: I mean.

661
01:31:55.480 --> 01:32:10.080
Patrik Stas: confusing or like advance. We already have, like lots of context about what we are doing. And you're just kind of like meeting aer 6 initially. So hopefully, it was any, any, any, any any good and useful for you

662
01:32:10.950 --> 01:32:12.070
Patrik Stas: as well?

663
01:32:14.980 --> 01:32:16.709
Naian: yes.

664
01:32:17.100 --> 01:32:20.870
Naian: it. It's sort of like passive learning, I guess.

665
01:32:22.260 --> 01:32:23.950
Patrik Stas: Yeah, you like, just kinda like.

666
01:32:24.020 --> 01:32:28.380
Patrik Stas: call, like the glimpse of like, kind of pattern here and there.

667
01:32:29.340 --> 01:32:30.070
Naian: Yes.

668
01:32:31.260 --> 01:32:32.030
Patrik Stas: yeah.

669
01:32:33.050 --> 01:32:44.200
Patrik Stas: Okay, folks thank you very much for for bearing this really long call, and have a great day and wonderful weekends with this and coming.

670
01:32:44.360 --> 01:32:47.399
Bogdan Mircea: So you know, Sam, thank you. Do have a good one. Bye.

